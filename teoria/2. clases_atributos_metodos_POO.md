
# Clases, Atributos y M√©todos en la Programaci√≥n Orientada a Objetos (POO)

La Programaci√≥n Orientada a Objetos (POO) es un paradigma que organiza el c√≥digo en torno a **clases** y **objetos**. A continuaci√≥n, exploraremos a fondo las clases, sus atributos y m√©todos, qu√© representan y c√≥mo se relacionan. Tambi√©n veremos principios de dise√±o asociados (como encapsulamiento, cohesi√≥n y responsabilidad √∫nica) y finalmente c√≥mo implementar estos conceptos en **Python**, con analog√≠as del mundo real y ejemplos pr√°cticos en c√≥digo.

## Definici√≥n conceptual de clase

En POO, una *clase* es una estructura o tipo de dato abstracto que combina datos y comportamientos en una sola entidad. La clase act√∫a como un **molde** o plantilla a partir del cual se pueden crear instancias concretas llamadas **objetos**. En otras palabras, la clase define qu√© **atributos** (datos, propiedades) y **m√©todos** (funciones, acciones) poseer√°n sus objetos, mientras que cada objeto es una realizaci√≥n espec√≠fica con sus propios valores para esos atributos.

Una analog√≠a com√∫n es pensar en la clase como el plano o dise√±o de un coche, que especifica sus caracter√≠sticas (ej. color, marca, modelo) y acciones posibles (ej. acelerar, frenar). Un objeto ser√≠a el coche real construido seg√∫n ese plano, con un color y modelo particular, y capaz de realizar esas acciones. Sin la clase (el plano general), el objeto no tendr√≠a estructura ni sentido; y sin objetos, la clase ser√≠a solo una definici√≥n te√≥rica.

Las clases suelen modelar entidades o conceptos del mundo real dentro del programa. Por ejemplo, podr√≠amos tener una clase `Coche` que abstrae las propiedades y comportamientos generales de los coches, y luego crear m√∫ltiples objetos `Coche` (instancias) para representar coches espec√≠ficos (un coche **concreto** de cierta marca, modelo y color). Definir claramente las clases y qu√© les pertenece permite **modelar entidades complejas de forma l√≥gica y coherente**, aprovechando las ventajas de la orientaci√≥n a objetos. Esto conduce a programas m√°s organizados y f√°ciles de mantener, ya que el c√≥digo relacionado se agrupa dentro de la clase correspondiente.

## Atributos: definici√≥n, tipos y visibilidad

Los **atributos** (tambi√©n conocidos como *propiedades* o *campos*) son las caracter√≠sticas o datos que describen el estado de un objeto. Representan la informaci√≥n que cada instancia de la clase almacena. Por ejemplo, en la clase `Coche`, posibles atributos ser√≠an `marca`, `modelo` y `color`, los cuales cada coche concreto tendr√° con valores propios. Cada objeto tiene **sus propios** valores para estos atributos, independientes de los de otros objetos de la misma clase. En un coche espec√≠fico `mi_coche` estos atributos podr√≠an ser `marca="Renault"`, `modelo="Clio"`, `color="Blanco"`, mientras que otro objeto `otro_coche` podr√≠a tener `marca="Toyota"`, `modelo="Yaris"`, `color="Azul"`.

**Tipos de atributos:** Podemos categorizar los atributos principalmente en dos tipos: de instancia y de clase:

* **Atributos de instancia:** Son aquellos definidos dentro de la clase pero que pertenecen a cada objeto individual. Se suelen inicializar en el constructor de la clase (por ejemplo, en Python dentro de `__init__`) usando la referencia al objeto (`self` en Python, `this` en Java, etc.). **Cada instancia** obtiene su propia copia de estos atributos. En el ejemplo de `Coche`, `marca`, `modelo` y `color` son atributos de instancia: cada objeto `Coche` tendr√° su propio valor para cada uno.

* **Atributos de clase:** Son atributos asociados a la clase en s√≠ misma, y **compartidos por todas** las instancias de esa clase. Se definen normalmente fuera de los m√©todos, directamente en la definici√≥n de la clase. Por ejemplo, podr√≠amos declarar `Coche.numero_ruedas = 4` dentro de la clase, indicando que *todos* los coches tienen 4 ruedas. Este atributo `numero_ruedas` es √∫nico para la clase: todas las instancias referencian al mismo valor almacenado a nivel de clase. Los atributos de clase son √∫tiles para propiedades constantes o comunes a todos los objetos (como constantes, contadores comunes, etc.). Es importante utilizarlos adecuadamente: si accidentalmente us√°ramos un atributo de clase para algo que deber√≠a variar por instancia, todas las instancias lo compartir√≠an. De hecho, **los datos compartidos pueden producir efectos inesperados**; por ejemplo, en Python si definimos una lista como atributo de clase, **todas** las instancias usar√°n la misma lista, provocando que cambios desde un objeto afecten a los dem√°s. La soluci√≥n en ese caso ser√≠a usar un atributo de instancia para que cada objeto tenga su propia lista.

**Visibilidad de atributos:** Muchos lenguajes orientados a objetos permiten controlar el acceso a los atributos mediante modificadores de visibilidad o acceso. Los niveles m√°s comunes son:

* **P√∫blico (public):** El atributo es accesible desde cualquier parte del programa. Es el nivel de acceso m√°s abierto (menor ocultamiento). Un atributo p√∫blico puede leerse o modificarse libremente desde fuera de la clase.

* **Protegido (protected):** El atributo solo es accesible desde la propia clase y sus subclases (clases que heredan de ella). A veces tambi√©n se permite el acceso desde otras clases del mismo *m√≥dulo* o *paquete* (dependiendo del lenguaje). Es un nivel intermedio: restringe el acceso externo, pero permite que clases relacionadas lo usen.

* **Privado (private):** El atributo √∫nicamente es accesible desde la misma clase donde se define. Ning√∫n c√≥digo externo (ni siquiera subclases) deber√≠a poder acceder directamente a un atributo privado. Es el nivel de mayor ocultamiento, usado para proteger completamente el estado interno de la clase.

El prop√≥sito de estas restricciones es **encapsular** el estado del objeto, exponiendo solo lo necesario. En lenguajes como Java, C++ o C# existen palabras clave expl√≠citas (`public`, `protected`, `private`) para declarar la visibilidad. En Python no hay palabras clave de acceso; en su lugar se sigue una **convenci√≥n de nombres**: se considera que un nombre que comienza con `_` (gui√≥n bajo) es de uso interno (equivalente a "protegido"), y si comienza con `__` (doble gui√≥n bajo) se interpreta como "privado" de la clase. Python aplicar√° *name mangling* (cambio de nombre interno) a atributos con `__` para dificultar su acceso desde fuera de la clase, aunque no es una seguridad absoluta. Por ejemplo, si en una clase Python definimos `self.__saldo`, no podremos acceder a ese valor haciendo `obj.__saldo` desde el exterior porque el int√©rprete renombra internamente `__saldo` a algo como `_NombreClase__saldo`.

**Buenas pr√°cticas:** Se recomienda dar a los atributos la **menor visibilidad necesaria** (principio de m√≠nimo privilegio). Esto significa que, por defecto, es mejor que los atributos sean privados o encapsulados, a menos que haya una raz√≥n para hacerlos p√∫blicos. Para permitir leer o modificar atributos privados desde fuera de la clase sin violar encapsulamiento, se suelen proporcionar m√©todos accesores: *getters* (ej. `getSaldo()`) para obtener el valor, y *setters* (ej. `setSaldo(valor)`) para modificarlo con validaci√≥n si procede. De este modo, el objeto controla c√≥mo se accede o cambia su estado interno. **Encapsular** los atributos de esta forma previene modificaciones accidentales o inconsistentes desde fuera. Por ejemplo, en una clase cuenta bancaria podr√≠amos tener un atributo privado `__saldo` y m√©todos p√∫blicos `depositar(cant)` o `obtener_saldo()`; as√≠, la l√≥gica interna de actualizaci√≥n de saldo queda dentro de la clase, y desde fuera solo se interact√∫a mediante esos m√©todos. Esta t√©cnica sigue el principio de ocultamiento de datos: es como tener los datos "bajo llave" y exponer solo ‚Äúpuertas‚Äù controladas para acceder a ellos. En resumen, los atributos deben mantenerse lo m√°s encapsulados posible para garantizar la integridad del objeto y reducir el acoplamiento con el c√≥digo externo.

## M√©todos: definici√≥n, tipos y sobrecarga

Los **m√©todos** son las acciones o comportamientos que los objetos de una clase pueden realizar. En t√©rminos t√©cnicos, un m√©todo es una funci√≥n definida dentro de la definici√≥n de la clase, que usualmente opera sobre los atributos del objeto o realiza alguna operaci√≥n relacionada. Siguiendo el ejemplo anterior, la clase `Coche` podr√≠a tener m√©todos como `acelerar()`, `frenar()` o `girar(angulo)`, representando acciones que un coche sabe hacer. Cuando invocamos un m√©todo en un objeto (por ejemplo `mi_coche.frenar()`), ese objeto ejecutar√° el c√≥digo del m√©todo usando *su propio estado interno* (sus atributos) para producir un resultado o modificar dicho estado.

**Tipos de m√©todos:** Dentro de la POO (y en distintos lenguajes) existen varios tipos de m√©todos, entre los principales:

* **M√©todos de instancia:** Son los m√©todos normales que operan sobre una instancia espec√≠fica de la clase. Solo pueden ser llamados a trav√©s de un objeto (instancia) y tienen acceso a los atributos particulares de ese objeto. En su definici√≥n, reciben impl√≠cita o expl√≠citamente una referencia al propio objeto (por ejemplo, el par√°metro `self` en Python o `this` en Java/C#). Esto les permite usar y modificar el estado del objeto. Ejemplo: si `mi_coche` es un objeto `Coche`, al llamar `mi_coche.acelerar()`, el m√©todo `acelerar` podr√° acceder a `self.marca`, `self.modelo`, etc. de `mi_coche` y, quiz√°s, cambiar alg√∫n atributo o imprimir algo relativo a ese coche.

* **M√©todos de clase:** Son m√©todos asociados a la *clase* en s√≠, m√°s que a objetos individuales. En Python se definen con el decorador `@classmethod` y reciben la clase como primer argumento (convencionalmente llamado `cls`). Esto significa que al llamarlos no operan sobre una instancia en particular, sino que pueden acceder o modificar estado que sea com√∫n a toda la clase (como atributos de clase). Un uso com√∫n de m√©todos de clase es ofrecer **constructores alternativos**. Por ejemplo, podr√≠amos tener `Coche.desde_cadena("Renault,Clio,Blanco")` que parsee una cadena y retorne un nuevo `Coche` creado con esos datos; ese m√©todo ser√≠a de clase porque devuelve un nuevo objeto `cls(...)`. En lenguajes como Java o C#, no existe exactamente un an√°logo llamado "m√©todo de clase" (todos los m√©todos pertenecen a alguna clase), pero lo equivalente ser√≠an m√©todos est√°ticos que operan a nivel de clase (ver siguiente punto).

* **M√©todos est√°ticos:** Son m√©todos que, a diferencia de los de instancia, **no reciben** ni la referencia a una instancia ni a la clase. En Python se se√±alan con `@staticmethod`. Act√∫an b√°sicamente como funciones normales definidas dentro del espacio de la clase (m√°s por organizaci√≥n l√≥gica que por necesidad t√©cnica). Un m√©todo est√°tico no puede acceder directamente a `self` ni a `cls`, por lo que **no puede manipular el estado del objeto ni de la clase**, a menos que se le pase expl√≠citamente. Se utilizan para operaciones auxiliares que tienen cierta relaci√≥n con la clase, pero que no dependen de una instancia. Por ejemplo, podr√≠amos definir `Coche.calcular_impuesto(anio)` que, dado un a√±o de fabricaci√≥n, calcule un impuesto te√≥rico para cualquier coche de ese a√±o; esta funci√≥n no necesita ni los atributos de instancia ni la clase en s√≠, as√≠ que encaja como m√©todo est√°tico. (En Java/C# todos los m√©todos marcados como `static` funcionan parecido a esto: pertenecen a la clase y no a instancias).

Adem√°s de lo anterior, muchos lenguajes soportan la **sobrecarga de m√©todos**. La *sobrecarga* significa que dentro de una misma clase podemos tener **dos o m√°s m√©todos con el mismo nombre** pero distinta **firma** o lista de par√°metros (diferente n√∫mero y/o tipo de par√°metros). Esto permite implementar variantes de una acci√≥n para distintos tipos de entradas. El compilador (en lenguajes est√°ticos) elige autom√°ticamente qu√© versi√≥n llamar seg√∫n los argumentos utilizados. Por ejemplo, una clase podr√≠a definir `area()` (sin par√°metros, que calcula el √°rea usando atributos internos) y tambi√©n `area(base, altura)` (que calcula el √°rea con valores proporcionados). Ambos m√©todos se llaman igual, pero se diferencian por sus par√°metros. **No se debe confundir** con la sobrescritura de m√©todos (override), que es un concepto distinto relacionado con redefinir en una subclase un m√©todo existente en la superclase.

> üí° **Nota:** Python **no admite sobrecarga de m√©todos** de la manera tradicional. Si definimos dos funciones con el mismo nombre en una clase, la definici√≥n posterior *reemplazar√°* a la anterior, quedando solo la √∫ltima. Para lograr comportamientos similares, Python ofrece otras v√≠as: por ejemplo, usar par√°metros opcionales con valores por defecto en un solo m√©todo (simulando m√∫ltiples firmas), o usar el decorador `@singledispatch` de `functools` para sobrecarga basada en tipo. En general, la filosof√≠a de Python tiende a preferir funciones/m√©todos que manejen diferentes tipos de entrada internamente en lugar de definir m√∫ltiples versiones del mismo m√©todo.

**Visibilidad de m√©todos:** Los m√©todos tambi√©n pueden restringir su acceso de forma similar a los atributos. Un *m√©todo p√∫blico* es parte de la interfaz de la clase, pensado para ser llamado desde el exterior (por c√≥digo de otros m√≥dulos u objetos). Un *m√©todo privado* (o de uso interno) se utiliza solo dentro de la clase, t√≠picamente para descomponer tareas complejas en sub-tareas o para operaciones auxiliares que no deban usar otros objetos. En lenguajes como Java, C++ o PHP podemos marcar un m√©todo como `private` o `protected` para limitar su alcance. En Python de nuevo se utiliza la convenci√≥n: un m√©todo cuyo nombre empieza con `_` indica "no lo uses desde fuera" (convenci√≥n de protegido), y si empieza con `__` se considera privado, siendo renombrado internamente por Python. Por ejemplo, podr√≠amos tener `def __calcular_saldo(self): ...` dentro de una clase cuenta bancaria para un m√©todo interno; el usuario de la clase no lo invocar√° directamente, en su lugar llamar√° a m√©todos p√∫blicos que internamente usan `__calcular_saldo`. En s√≠ntesis, la visibilidad de m√©todos permite a la clase exponer solo las operaciones seguras y pertinentes, ocultando los detalles de implementaci√≥n o pasos intermedios (esto nuevamente es parte del encapsulamiento, tratado m√°s abajo).

## Relaci√≥n entre clase, objeto, atributos y m√©todos

Las clases, los objetos, sus atributos y m√©todos est√°n estrechamente relacionados y se organizan de forma jer√°rquica. La **clase** define la estructura y el comportamiento: es decir, declara qu√© atributos (estado) y m√©todos (comportamiento) tendr√°n sus objetos. Un **objeto** (tambi√©n llamado instancia) es la manifestaci√≥n concreta de esa clase: cuando "instanciamos" una clase, creamos un objeto real en memoria que tiene sus propios valores de atributos y la capacidad de ejecutar los m√©todos definidos por la clase.

Cada objeto mantiene su **propio estado interno** a trav√©s de sus atributos. Objetos distintos de la misma clase tienen copias separadas de esos atributos, potencialmente con diferentes valores. Por ejemplo, si `Coche` define un atributo `color`, podemos crear dos objetos `Coche`: uno con `color="Rojo"` y otro con `color="Azul"`. Estos dos objetos comparten la misma definici√≥n (misma estructura de atributos y m√©todos), pero sus estados son independientes: cambiar el color de uno no afecta al otro. En c√≥digo Python, podr√≠amos ver algo as√≠:

```python
coche1 = Coche("Ford", "Fiesta", "Rojo")
coche2 = Coche("Ford", "Fiesta", "Azul")
print(coche1.color)  # Rojo
print(coche2.color)  # Azul (independiente de coche1)
```

Como se aprecia, **cada instancia mantiene sus propios valores** de atributos, reflejando la independencia entre objetos creados a partir de la misma clase. Todos los objetos *comparten* la definici√≥n de clase (saben qu√© es `color` y que existe un m√©todo `acelerar()`, por ejemplo), pero cada uno tiene sus propios datos.

Los **m√©todos** act√∫an como comportamientos *generales* definidos en la clase, pero cuando se invocan en un objeto, operan sobre el estado particular de ese objeto. Esto significa que el mismo m√©todo puede dar resultados distintos seg√∫n la instancia que lo ejecute. Por ejemplo, supongamos que la clase `Coche` tiene un m√©todo `acelerar()` que imprime un mensaje usando la marca y modelo del coche. Si `mi_coche` es un objeto con marca "Renault" y modelo "Clio", entonces `mi_coche.acelerar()` podr√≠a imprimir *"El Renault Clio est√° acelerando."*. Ahora, si `otro_coche` tiene marca "Toyota" y modelo "Yaris", al llamar `otro_coche.acelerar()`, el m√©todo usar√° los atributos de `otro_coche` y quiz√° imprima *"El Toyota Yaris est√° acelerando."*. El **c√≥digo del m√©todo `acelerar` es √∫nico** (definido una vez en la clase), pero el contexto de cada objeto (`self`) hace que opere con datos diferentes en cada caso.

En otras palabras, la clase proporciona la **l√≥gica com√∫n**, y cada objeto aporta su **estado propio** sobre el que se aplica esa l√≥gica. Los m√©todos tienen impl√≠citamente acceso a los atributos del objeto que los invoca, lo que vincula datos y comportamiento. Esta relaci√≥n es el coraz√≥n de la POO: un objeto combina ciertos datos con las funciones capaces de manipular esos datos.

Otra forma de verlo es pensando en la **encapsulaci√≥n** que ofrece la clase: dentro de cada objeto coexisten sus atributos (datos) y m√©todos (operaciones) que saben c√≥mo usar esos datos. Por fuera, podemos considerar al objeto como una unidad con identidad propia, que responde a mensajes (llamadas de m√©todos) y puede cambiar su estado interno en respuesta. La clase define esa "unidad" y las reglas de interacci√≥n, pero es en los objetos donde realmente sucede la din√°mica (almacenamiento de valores concretos y ejecuci√≥n de m√©todos con efectos).

Como analog√≠a final, volvamos al mundo real: pensemos en una clase como la receta de un pastel, que indica ingredientes (atributos) y pasos (m√©todos) para prepararlo. Un objeto ser√≠a un pastel espec√≠fico que horneamos siguiendo esa receta. Cada pastel resultante tiene sus propios ingredientes concretos (cantidad de az√∫car, sabor, etc. seg√∫n la instancia) pero todos se hicieron siguiendo las mismas instrucciones. Cada pastel "sabe" c√≥mo prepararse (porque la receta define el m√©todo), pero aplicar√° esas instrucciones con sus propias cantidades e ingredientes particulares. As√≠ interact√∫an clase, atributos y m√©todos para darle vida a objetos concretos.

## Principios de dise√±o relacionados (encapsulamiento, cohesi√≥n, SRP, etc.)

Al dise√±ar clases en POO, no basta con hacerlas funcionar; tambi√©n buscamos que su dise√±o sea **robusto, claro y mantenible**. Para ello, se aplican una serie de principios de dise√±o de software. A continuaci√≥n, explicamos algunos de los m√°s importantes y c√≥mo se relacionan con clases, atributos y m√©todos:

* **Encapsulamiento:** Este principio establece que cada clase debe *encerrar* o *agrupar* tanto los datos como las operaciones que act√∫an sobre esos datos, y controlar el acceso a ellos. Dicho de otro modo, el encapsulamiento consiste en unir en la clase las caracter√≠sticas (atributos) y comportamientos (m√©todos) relacionados, formando una sola entidad l√≥gica. Adem√°s, implica **ocultar la implementaci√≥n interna** y exponer solo una interfaz limitada para interactuar con el objeto. La clase puede ser vista como una caja negra: uno conoce qu√© hace (m√©todos p√∫blicos), pero no necesariamente c√≥mo lo hace internamente. Por ejemplo, al usar un televisor solo interactuamos con sus botones o el control remoto; no necesitamos saber qu√© ocurre en los circuitos internos para cambiar de canal o subir el volumen. De forma similar, gracias al encapsulamiento en software podemos **proteger los datos internos** y permitir acceso solo a trav√©s de m√©todos p√∫blicos seguros. Esto brinda dos ventajas: (1) evitamos que el estado interno sea modificado de manera inconsistente o indebida desde fuera (p. ej., podr√≠amos validar en un setter que una edad nunca sea negativa antes de asignarla a un atributo), y (2) podemos cambiar la implementaci√≥n interna de una clase sin afectar el c√≥digo externo que la usa, siempre que mantengamos la misma interfaz. En la pr√°ctica, logramos encapsulaci√≥n haciendo atributos privados y definiendo m√©todos p√∫blicos para accederlos o modificarlos de forma controlada. El encapsulamiento aumenta la **cohesi√≥n interna** de la clase (mantiene juntos datos y funciones relacionadas) y sienta las bases para reducir el acoplamiento con otras partes del programa.

* **Cohesi√≥n:** La cohesi√≥n mide qu√© tan enfocadas est√°n las responsabilidades de una clase (o m√≥dulo). Una clase tiene **alta cohesi√≥n** cuando **todos sus atributos y m√©todos est√°n fuertemente relacionados** entre s√≠ y contribuyen a una √∫nica finalidad o funcionalidad principal. Por el contrario, una clase con responsabilidades muy dispares se considera de baja cohesi√≥n. Por ejemplo, si se crea una clase `Utilidades` que maneja l√≥gica de interfaz gr√°fica *y* c√°lculo matem√°tico *y* acceso a base de datos, tendr√≠a muy baja cohesi√≥n (hace muchas cosas inconexas). En cambio, si dividimos ese dise√±o en clases m√°s especializadas (ej. una clase para la UI, otra para c√°lculos, otra para la base de datos), cada una ser√° m√°s cohesiva. **Alta cohesi√≥n** es deseable porque las clases simples y enfocadas son m√°s f√°ciles de comprender, depurar y reutilizar. Adem√°s, suelen ser m√°s f√°ciles de mantener: un cambio en requisitos afecta a una clase espec√≠fica en lugar de a una mezcla de funcionalidades. De hecho, la cohesi√≥n est√° estrechamente ligada al principio de responsabilidad √∫nica (SRP) que veremos a continuaci√≥n.

* **Principio de Responsabilidad √önica (SRP):** El SRP (Single Responsibility Principle) postula que *cada clase debe tener una √∫nica responsabilidad o motivo de cambio*. Robert C. Martin lo resume as√≠: **"Nunca deber√≠a haber m√°s de una raz√≥n por la cual una clase deba cambiar"**. En otras palabras, una clase debe encapsular solo una parcela de l√≥gica o funcionalidad. Si una clase atiende a m√∫ltiples prop√≥sitos, es probable que deba modificarse por motivos distintos y termine rompiendo este principio. Aplicar SRP t√≠picamente nos gu√≠a a clases m√°s peque√±as y altamente cohesionadas, donde todos sus miembros se orientan a cumplir ese √∫nico rol. Por ejemplo, podr√≠amos tener una clase `GestorArchivos` cuya √∫nica responsabilidad sea leer/escribir archivos. Si adem√°s esta clase estuviera manejando la interfaz gr√°fica para seleccionar archivos, estar√≠a teniendo dos responsabilidades (gesti√≥n de archivos y presentaci√≥n UI), violando SRP. La soluci√≥n ser√≠a separar: una clase se encarga de la l√≥gica de archivos, otra de la interfaz. De esta forma, cada clase tiene un √∫nico motivo para cambiar (p.ej., la clase de archivos solo cambiar√≠a si cambia la forma de acceder al sistema de archivos). Esto mejora la mantenibilidad y evita las "clases dios" o clases monol√≠ticas que hacen de todo. Mantener cada clase enfocada en un solo prop√≥sito tambi√©n facilita reutilizarla en distintos contextos.

* **Acoplamiento:** El acoplamiento se refiere al grado de dependencia o interconexi√≥n entre distintas clases o m√≥dulos. Un sistema bien dise√±ado busca **bajo acoplamiento**, es decir, que las clases interact√∫en entre s√≠ de forma m√≠nima y a trav√©s de interfaces claras. Si dos clases est√°n fuertemente acopladas, un cambio en una podr√≠a requerir cambios en la otra; esto dificulta la extensi√≥n y el mantenimiento del c√≥digo. Por ejemplo, si la clase A depende directamente de muchos detalles internos de la clase B, cualquier modificaci√≥n en B podr√≠a romper a A. En cambio, si A y B se comunican a trav√©s de una interfaz abstracta o m√≠nima, B puede cambiar internamente sin impactar a A. El acoplamiento suele ser inversamente proporcional a la cohesi√≥n: clases muy cohesivas tienden a tener menos dependencias con otras, porque hacen solo una cosa y se relacionan con pocas partes externas. Mediante encapsulamiento y SRP normalmente se logra **alta cohesi√≥n y bajo acoplamiento**, meta central del buen dise√±o OO. Un ejemplo pr√°ctico es dividir la l√≥gica de negocio de la de interfaz gr√°fica: si est√°n bien separadas en clases distintas y solo se comunican a trav√©s de m√©todos p√∫blicos necesarios, un cambio en la l√≥gica de negocio no romper√° la interfaz y viceversa (bajo acoplamiento). Clases con bajo acoplamiento pueden modificarse o reemplazarse con menor efecto domin√≥ en el sistema.

En conjunto, estos principios (encapsulamiento, cohesi√≥n, responsabilidad √∫nica y bajo acoplamiento) contribuyen a un dise√±o orientado a objetos **m√°s s√≥lido y mantenible**. Gracias al encapsulamiento, los objetos act√∫an como unidades aut√≥nomas con interfaces bien definidas, permitiendo cambiar implementaciones internas sin afectar a quien las usa (principio de *abierto/cerrado*, Open/Closed). La cohesi√≥n y SRP nos aseguran clases claras y enfocadas, facilitando la comprensi√≥n y pruebas unitarias. Y minimizando el acoplamiento logramos que las distintas partes del sistema est√©n lo m√°s independientes posible, reduciendo errores colaterales y favoreciendo la reutilizaci√≥n. No es coincidencia que estos conceptos sean promovidos por los principios **SOLID** de dise√±o de software, cuyo fin es lograr c√≥digo de calidad: f√°cil de mantener, escalar y adaptar a cambios. Aplic√°ndolos, obtenemos clases que funcionan juntas armoniosamente: cada una bien definida (cohesiva), protegida en su comportamiento interno (encapsulada), haciendo solo su trabajo (SRP) y comunic√°ndose con otras de forma controlada (bajo acoplamiento).

## C√≥mo se implementa todo esto en Python: sintaxis, convenciones y ejemplos

Finalmente, veamos c√≥mo llevar a la pr√°ctica las clases, atributos y m√©todos en **Python**, uno de los lenguajes m√°s populares hoy en d√≠a. Python es multiparadigma pero ofrece soporte claro para POO. A continuaci√≥n, definiremos una clase de ejemplo y analizaremos su sintaxis, siguiendo las convenciones t√≠picas:

```python
class Coche:
    numero_ruedas = 4  # Atributo de clase (compartido por todos los Coche)
    
    def __init__(self, marca, modelo, color):
        # Atributos de instancia (propios de cada objeto)
        self.marca = marca
        self.modelo = modelo
        self.color = color
    
    def acelerar(self):
        print(f"El {self.marca} {self.modelo} est√° acelerando.")
    
    def frenar(self):
        print(f"El {self.marca} {self.modelo} est√° frenando.")
    
    @classmethod
    def obtener_ruedas(cls):
        """M√©todo de clase: devuelve el n√∫mero de ruedas est√°ndar."""
        return cls.numero_ruedas
    
    @staticmethod
    def velocidad_maxima():
        """M√©todo est√°tico: devuelve una velocidad fija de referencia."""
        return 240
```

En este c√≥digo, definimos la clase `Coche`. Veamos punto por punto:

* La l√≠nea `numero_ruedas = 4` declara un atributo de clase. Este valor reside en la clase `Coche` en s√≠ y es *√∫nico* para todos los coches (todos comparten `numero_ruedas=4`).

* El m√©todo especial `__init__` es el **constructor** en Python. Se llama autom√°ticamente al crear un nuevo `Coche`. Sus par√°metros (`marca, modelo, color`) son los datos necesarios para instanciar un coche, y dentro de `__init__` asignamos esos valores a los atributos de instancia usando `self` (que representa el objeto que se est√° creando). As√≠, cada objeto `Coche` nuevo tendr√° su propia `self.marca`, `self.modelo` y `self.color`.

* `acelerar` y `frenar` son **m√©todos de instancia**. Al definirse dentro de la clase, Python autom√°ticamente har√° que el primer par√°metro sea `self`, representando al objeto desde el cual se invoque el m√©todo. En el cuerpo de estas funciones, usamos `self.marca` y `self.modelo` para acceder a datos del objeto y, en este caso, imprimir un mensaje. Son m√©todos t√≠picos que operan sobre el estado del objeto que los llama.

* `obtener_ruedas` est√° precedido por `@classmethod`. Esto indica que es un **m√©todo de clase**. En lugar de `self`, recibe `cls` (la propia clase `Coche`). Dentro del m√©todo usamos `cls.numero_ruedas` para acceder al atributo de clase y retornarlo. Esto podr√≠a servir, por ejemplo, para consultar la configuraci√≥n com√∫n de todos los coches. Los m√©todos de clase se pueden llamar tanto desde la clase (`Coche.obtener_ruedas()`) como desde una instancia (`mi_coche.obtener_ruedas()`), pero en cualquier caso el par√°metro `cls` referir√° a la clase `Coche`.

* `velocidad_maxima` est√° definido con `@staticmethod`. Es un **m√©todo est√°tico**, lo que significa que no recibe `self` ni `cls` autom√°ticamente. Es simplemente una funci√≥n colocada dentro de la clase por organizaci√≥n. En el ejemplo, `velocidad_maxima()` devuelve un valor constante (digamos 240 km/h) sin depender de ning√∫n dato de instancia ni de clase. Podemos invocarlo como `Coche.velocidad_maxima()` y obtener siempre el mismo resultado. Un m√©todo est√°tico podr√≠a usarse para c√°lculos gen√©ricos relacionados con los coches (por ejemplo, convertir unidades de velocidad) que no requieran informaci√≥n espec√≠fica de un coche en particular.

**Instanciaci√≥n y uso de objetos:** Para crear (instanciar) un objeto de una clase en Python, llamamos a la clase como si fuese una funci√≥n, pasando los argumentos que el `__init__` espera. Por ejemplo:

```python
# Crear instancias de Coche
mi_coche = Coche("Renault", "Clio", "Blanco")
otro_coche = Coche("Toyota", "Yaris", "Azul")

# Acceder a atributos de instancia
print(mi_coche.marca)    # Renault
print(mi_coche.color)    # Blanco
print(otro_coche.color)  # Azul

# Invocar m√©todos de instancia
mi_coche.acelerar()      # El Renault Clio est√° acelerando.
otro_coche.frenar()      # El Toyota Yaris est√° frenando.

# Uso de atributo de clase (compartido)
print(Coche.numero_ruedas)    # 4
print(mi_coche.numero_ruedas) # 4  (las instancias lo comparten)

# Invocar m√©todo de clase y est√°tico
print(Coche.obtener_ruedas())   # 4
print(Coche.velocidad_maxima()) # 240
```

Veamos qu√© ocurre en este c√≥digo:

* Al hacer `Coche("Renault","Clio","Blanco")`, Python crea un nuevo objeto `Coche` y llama a `__init__` pasando `self` (el nuevo objeto) y los argumentos proporcionados. Dentro de `__init__`, se asignan `self.marca = "Renault"`, etc. El resultado es que `mi_coche` es un objeto con esos atributos inicializados. Del mismo modo, `otro_coche` tendr√° sus propios valores. Ahora, **cada objeto tiene sus atributos poblados con datos distintos**.

* Podemos acceder a los atributos de instancia con la sintaxis `objeto.atributo` (por ejemplo `mi_coche.marca`). Esto nos devuelve el valor almacenado en ese objeto. Como vimos, `mi_coche.color` puede ser "Blanco" mientras `otro_coche.color` es "Azul", sin conflicto.

* Al invocar un **m√©todo de instancia** como `mi_coche.acelerar()`, internamente Python traduce esa llamada a `Coche.acelerar(mi_coche)`. Es decir, llama a la funci√≥n `acelerar` definida en la clase, pasando el objeto `mi_coche` como `self`. Por eso, dentro de `acelerar`, cuando hacemos `print(f"El {self.marca} {self.modelo} est√° acelerando.")`, `self.marca` corresponde a `mi_coche.marca` ("Renault") y `self.modelo` a "Clio", produciendo *"El Renault Clio est√° acelerando."*. Si llamamos `otro_coche.frenar()`, ocurrir√° an√°logamente: Python invoca `Coche.frenar(otro_coche)` y dentro del m√©todo `self` ser√° `otro_coche`, usando sus valores ("Toyota Yaris"). As√≠, los m√©todos operan sobre los datos del objeto que los llama, cumpliendo el paradigma objeto->mensaje (el objeto sabe c√≥mo ejecutar la acci√≥n con sus propios datos).

* El **atributo de clase** `numero_ruedas` es accesible tanto a trav√©s de la clase como de las instancias. `Coche.numero_ruedas` obviamente retorna 4. Curiosamente, `mi_coche.numero_ruedas` tambi√©n retornar√° 4, porque al no encontrar `numero_ruedas` en el diccionario de atributos de `mi_coche`, Python va a buscarlo en la clase `Coche` y lo encuentra. Sin embargo, si intent√°ramos modificar `mi_coche.numero_ruedas` asign√°ndole otro valor, estar√≠amos en realidad creando un **nuevo atributo de instancia** en `mi_coche` que oculta al de clase (no cambiar√≠a el valor en la clase ni en otras instancias). Por tanto, para modificar un atributo de clase es recomendable hacerlo mediante la clase misma (`Coche.numero_ruedas = X`). En nuestro ejemplo no cambiamos `numero_ruedas` porque es una constante conceptual de los coches.

* En cuanto a los **m√©todos de clase y est√°ticos**, vemos que los llamamos desde la clase (`Coche.obtener_ruedas()`, `Coche.velocidad_maxima()`). El m√©todo de clase `obtener_ruedas` devuelve `cls.numero_ruedas`, que en este contexto es `Coche.numero_ruedas`, por lo que retorna 4 (coincidiendo con lo que imprimimos antes). Podr√≠amos tambi√©n llamar `mi_coche.obtener_ruedas()`: Python interpretar√° eso como llamada de m√©todo de clase pasando `cls = Coche` igualmente, as√≠ que retornar√≠a lo mismo. El m√©todo est√°tico `velocidad_maxima()` no depende de nada y simplemente devuelve 240 siempre, lo cual comprobamos en el print.

**Convenciones y detalles de Python:** A diferencia de lenguajes como Java, en Python no existen restricciones de visibilidad enforced por el lenguaje. **Todo atributo o m√©todo es p√∫blicamente accesible** por dise√±o. Sin embargo, siguiendo el esp√≠ritu del encapsulamiento, los desarrolladores Python utilizan las convenciones mencionadas: nombre iniciando con `_` para indicar "esto es interno, por favor no lo uses externamente" y con `__` para "estrictamente interno/privado". Por ejemplo, si en nuestra clase `Coche` quisi√©ramos que el atributo `color` fuera privado, podr√≠amos cambiarlo a `self.__color` en `__init__` y ajustar los m√©todos. Desde fuera, intentar `mi_coche.__color` no funcionar√° (Python habr√° *mangleado* el nombre a `_Coche__color` para esa instancia). Solo m√©todos de `Coche` podr√≠an acceder a `__color`. Y si quisi√©ramos proveer lectura/escritura segura, a√±adir√≠amos, por ejemplo, `def get_color(self): return self.__color` y quiz√°s `def repintar(self, nuevo_color): self.__color = nuevo_color` con la l√≥gica necesaria.

En cuanto a **estilo**, Python recomienda (PEP 8) nombrar las clases usando **CamelCase** (PrimeraLetraMay√∫scula, e.j. `ClaseEjemplo`), y los nombres de m√©todos y atributos en **snake\_case** (min√∫sculas\_con\_guiones\_bajos). Adem√°s, por convenci√≥n el primer par√°metro de m√©todos de instancia se llama `self` (aunque t√©cnicamente podr√≠a tener otro nombre, todos usan `self` por legibilidad). Estas convenciones hacen el c√≥digo m√°s legible y est√°ndar dentro de la comunidad Python.

En resumen, Python implementa las clases de forma flexible: nos permite definir atributos de instancia y de clase f√°cilmente, m√©todos de instancia, de clase y est√°ticos con simples decoradores, e incluso simular privacidad mediante convenciones de nombres. Si bien Python no impone encapsulamiento mediante restricciones de acceso, es responsabilidad del desarrollador seguir las buenas pr√°cticas para lograr dise√±os orientados a objetos limpios. El ejemplo de la clase `Coche` ilustra c√≥mo una clase define un concepto (un coche con ciertas propiedades) y brinda funciones asociadas (m√©todos como acelerar/frenar), y c√≥mo podemos crear m√∫ltiples objetos independientes de esa clase para modelar elementos reales. Cada objeto `Coche` maneja su propio estado (ej. cada coche tiene su propio color) mientras comparte la misma definici√≥n de comportamiento. As√≠, la teor√≠a de clases, atributos y m√©todos se materializa en Python de forma directa, permitiendo **mapear problemas del mundo real a c√≥digo** de manera natural, que es en esencia el poder de la Programaci√≥n Orientada a Objetos.&#x20;
