
# Clases, Atributos y Métodos en la Programación Orientada a Objetos (POO)

La Programación Orientada a Objetos (POO) es un paradigma que organiza el código en torno a **clases** y **objetos**. A continuación, exploraremos a fondo las clases, sus atributos y métodos, qué representan y cómo se relacionan. También veremos principios de diseño asociados (como encapsulamiento, cohesión y responsabilidad única) y finalmente cómo implementar estos conceptos en **Python**, con analogías del mundo real y ejemplos prácticos en código.

## Definición conceptual de clase

En POO, una *clase* es una estructura o tipo de dato abstracto que combina datos y comportamientos en una sola entidad. La clase actúa como un **molde** o plantilla a partir del cual se pueden crear instancias concretas llamadas **objetos**. En otras palabras, la clase define qué **atributos** (datos, propiedades) y **métodos** (funciones, acciones) poseerán sus objetos, mientras que cada objeto es una realización específica con sus propios valores para esos atributos.

Una analogía común es pensar en la clase como el plano o diseño de un coche, que especifica sus características (ej. color, marca, modelo) y acciones posibles (ej. acelerar, frenar). Un objeto sería el coche real construido según ese plano, con un color y modelo particular, y capaz de realizar esas acciones. Sin la clase (el plano general), el objeto no tendría estructura ni sentido; y sin objetos, la clase sería solo una definición teórica.

Las clases suelen modelar entidades o conceptos del mundo real dentro del programa. Por ejemplo, podríamos tener una clase `Coche` que abstrae las propiedades y comportamientos generales de los coches, y luego crear múltiples objetos `Coche` (instancias) para representar coches específicos (un coche **concreto** de cierta marca, modelo y color). Definir claramente las clases y qué les pertenece permite **modelar entidades complejas de forma lógica y coherente**, aprovechando las ventajas de la orientación a objetos. Esto conduce a programas más organizados y fáciles de mantener, ya que el código relacionado se agrupa dentro de la clase correspondiente.

## Atributos: definición, tipos y visibilidad

Los **atributos** (también conocidos como *propiedades* o *campos*) son las características o datos que describen el estado de un objeto. Representan la información que cada instancia de la clase almacena. Por ejemplo, en la clase `Coche`, posibles atributos serían `marca`, `modelo` y `color`, los cuales cada coche concreto tendrá con valores propios. Cada objeto tiene **sus propios** valores para estos atributos, independientes de los de otros objetos de la misma clase. En un coche específico `mi_coche` estos atributos podrían ser `marca="Renault"`, `modelo="Clio"`, `color="Blanco"`, mientras que otro objeto `otro_coche` podría tener `marca="Toyota"`, `modelo="Yaris"`, `color="Azul"`.

**Tipos de atributos:** Podemos categorizar los atributos principalmente en dos tipos: de instancia y de clase:

* **Atributos de instancia:** Son aquellos definidos dentro de la clase pero que pertenecen a cada objeto individual. Se suelen inicializar en el constructor de la clase (por ejemplo, en Python dentro de `__init__`) usando la referencia al objeto (`self` en Python, `this` en Java, etc.). **Cada instancia** obtiene su propia copia de estos atributos. En el ejemplo de `Coche`, `marca`, `modelo` y `color` son atributos de instancia: cada objeto `Coche` tendrá su propio valor para cada uno.

* **Atributos de clase:** Son atributos asociados a la clase en sí misma, y **compartidos por todas** las instancias de esa clase. Se definen normalmente fuera de los métodos, directamente en la definición de la clase. Por ejemplo, podríamos declarar `Coche.numero_ruedas = 4` dentro de la clase, indicando que *todos* los coches tienen 4 ruedas. Este atributo `numero_ruedas` es único para la clase: todas las instancias referencian al mismo valor almacenado a nivel de clase. Los atributos de clase son útiles para propiedades constantes o comunes a todos los objetos (como constantes, contadores comunes, etc.). Es importante utilizarlos adecuadamente: si accidentalmente usáramos un atributo de clase para algo que debería variar por instancia, todas las instancias lo compartirían. De hecho, **los datos compartidos pueden producir efectos inesperados**; por ejemplo, en Python si definimos una lista como atributo de clase, **todas** las instancias usarán la misma lista, provocando que cambios desde un objeto afecten a los demás. La solución en ese caso sería usar un atributo de instancia para que cada objeto tenga su propia lista.

**Visibilidad de atributos:** Muchos lenguajes orientados a objetos permiten controlar el acceso a los atributos mediante modificadores de visibilidad o acceso. Los niveles más comunes son:

* **Público (public):** El atributo es accesible desde cualquier parte del programa. Es el nivel de acceso más abierto (menor ocultamiento). Un atributo público puede leerse o modificarse libremente desde fuera de la clase.

* **Protegido (protected):** El atributo solo es accesible desde la propia clase y sus subclases (clases que heredan de ella). A veces también se permite el acceso desde otras clases del mismo *módulo* o *paquete* (dependiendo del lenguaje). Es un nivel intermedio: restringe el acceso externo, pero permite que clases relacionadas lo usen.

* **Privado (private):** El atributo únicamente es accesible desde la misma clase donde se define. Ningún código externo (ni siquiera subclases) debería poder acceder directamente a un atributo privado. Es el nivel de mayor ocultamiento, usado para proteger completamente el estado interno de la clase.

El propósito de estas restricciones es **encapsular** el estado del objeto, exponiendo solo lo necesario. En lenguajes como Java, C++ o C# existen palabras clave explícitas (`public`, `protected`, `private`) para declarar la visibilidad. En Python no hay palabras clave de acceso; en su lugar se sigue una **convención de nombres**: se considera que un nombre que comienza con `_` (guión bajo) es de uso interno (equivalente a "protegido"), y si comienza con `__` (doble guión bajo) se interpreta como "privado" de la clase. Python aplicará *name mangling* (cambio de nombre interno) a atributos con `__` para dificultar su acceso desde fuera de la clase, aunque no es una seguridad absoluta. Por ejemplo, si en una clase Python definimos `self.__saldo`, no podremos acceder a ese valor haciendo `obj.__saldo` desde el exterior porque el intérprete renombra internamente `__saldo` a algo como `_NombreClase__saldo`.

**Buenas prácticas:** Se recomienda dar a los atributos la **menor visibilidad necesaria** (principio de mínimo privilegio). Esto significa que, por defecto, es mejor que los atributos sean privados o encapsulados, a menos que haya una razón para hacerlos públicos. Para permitir leer o modificar atributos privados desde fuera de la clase sin violar encapsulamiento, se suelen proporcionar métodos accesores: *getters* (ej. `getSaldo()`) para obtener el valor, y *setters* (ej. `setSaldo(valor)`) para modificarlo con validación si procede. De este modo, el objeto controla cómo se accede o cambia su estado interno. **Encapsular** los atributos de esta forma previene modificaciones accidentales o inconsistentes desde fuera. Por ejemplo, en una clase cuenta bancaria podríamos tener un atributo privado `__saldo` y métodos públicos `depositar(cant)` o `obtener_saldo()`; así, la lógica interna de actualización de saldo queda dentro de la clase, y desde fuera solo se interactúa mediante esos métodos. Esta técnica sigue el principio de ocultamiento de datos: es como tener los datos "bajo llave" y exponer solo “puertas” controladas para acceder a ellos. En resumen, los atributos deben mantenerse lo más encapsulados posible para garantizar la integridad del objeto y reducir el acoplamiento con el código externo.

## Métodos: definición, tipos y sobrecarga

Los **métodos** son las acciones o comportamientos que los objetos de una clase pueden realizar. En términos técnicos, un método es una función definida dentro de la definición de la clase, que usualmente opera sobre los atributos del objeto o realiza alguna operación relacionada. Siguiendo el ejemplo anterior, la clase `Coche` podría tener métodos como `acelerar()`, `frenar()` o `girar(angulo)`, representando acciones que un coche sabe hacer. Cuando invocamos un método en un objeto (por ejemplo `mi_coche.frenar()`), ese objeto ejecutará el código del método usando *su propio estado interno* (sus atributos) para producir un resultado o modificar dicho estado.

**Tipos de métodos:** Dentro de la POO (y en distintos lenguajes) existen varios tipos de métodos, entre los principales:

* **Métodos de instancia:** Son los métodos normales que operan sobre una instancia específica de la clase. Solo pueden ser llamados a través de un objeto (instancia) y tienen acceso a los atributos particulares de ese objeto. En su definición, reciben implícita o explícitamente una referencia al propio objeto (por ejemplo, el parámetro `self` en Python o `this` en Java/C#). Esto les permite usar y modificar el estado del objeto. Ejemplo: si `mi_coche` es un objeto `Coche`, al llamar `mi_coche.acelerar()`, el método `acelerar` podrá acceder a `self.marca`, `self.modelo`, etc. de `mi_coche` y, quizás, cambiar algún atributo o imprimir algo relativo a ese coche.

* **Métodos de clase:** Son métodos asociados a la *clase* en sí, más que a objetos individuales. En Python se definen con el decorador `@classmethod` y reciben la clase como primer argumento (convencionalmente llamado `cls`). Esto significa que al llamarlos no operan sobre una instancia en particular, sino que pueden acceder o modificar estado que sea común a toda la clase (como atributos de clase). Un uso común de métodos de clase es ofrecer **constructores alternativos**. Por ejemplo, podríamos tener `Coche.desde_cadena("Renault,Clio,Blanco")` que parsee una cadena y retorne un nuevo `Coche` creado con esos datos; ese método sería de clase porque devuelve un nuevo objeto `cls(...)`. En lenguajes como Java o C#, no existe exactamente un análogo llamado "método de clase" (todos los métodos pertenecen a alguna clase), pero lo equivalente serían métodos estáticos que operan a nivel de clase (ver siguiente punto).

* **Métodos estáticos:** Son métodos que, a diferencia de los de instancia, **no reciben** ni la referencia a una instancia ni a la clase. En Python se señalan con `@staticmethod`. Actúan básicamente como funciones normales definidas dentro del espacio de la clase (más por organización lógica que por necesidad técnica). Un método estático no puede acceder directamente a `self` ni a `cls`, por lo que **no puede manipular el estado del objeto ni de la clase**, a menos que se le pase explícitamente. Se utilizan para operaciones auxiliares que tienen cierta relación con la clase, pero que no dependen de una instancia. Por ejemplo, podríamos definir `Coche.calcular_impuesto(anio)` que, dado un año de fabricación, calcule un impuesto teórico para cualquier coche de ese año; esta función no necesita ni los atributos de instancia ni la clase en sí, así que encaja como método estático. (En Java/C# todos los métodos marcados como `static` funcionan parecido a esto: pertenecen a la clase y no a instancias).

Además de lo anterior, muchos lenguajes soportan la **sobrecarga de métodos**. La *sobrecarga* significa que dentro de una misma clase podemos tener **dos o más métodos con el mismo nombre** pero distinta **firma** o lista de parámetros (diferente número y/o tipo de parámetros). Esto permite implementar variantes de una acción para distintos tipos de entradas. El compilador (en lenguajes estáticos) elige automáticamente qué versión llamar según los argumentos utilizados. Por ejemplo, una clase podría definir `area()` (sin parámetros, que calcula el área usando atributos internos) y también `area(base, altura)` (que calcula el área con valores proporcionados). Ambos métodos se llaman igual, pero se diferencian por sus parámetros. **No se debe confundir** con la sobrescritura de métodos (override), que es un concepto distinto relacionado con redefinir en una subclase un método existente en la superclase.

> 💡 **Nota:** Python **no admite sobrecarga de métodos** de la manera tradicional. Si definimos dos funciones con el mismo nombre en una clase, la definición posterior *reemplazará* a la anterior, quedando solo la última. Para lograr comportamientos similares, Python ofrece otras vías: por ejemplo, usar parámetros opcionales con valores por defecto en un solo método (simulando múltiples firmas), o usar el decorador `@singledispatch` de `functools` para sobrecarga basada en tipo. En general, la filosofía de Python tiende a preferir funciones/métodos que manejen diferentes tipos de entrada internamente en lugar de definir múltiples versiones del mismo método.

**Visibilidad de métodos:** Los métodos también pueden restringir su acceso de forma similar a los atributos. Un *método público* es parte de la interfaz de la clase, pensado para ser llamado desde el exterior (por código de otros módulos u objetos). Un *método privado* (o de uso interno) se utiliza solo dentro de la clase, típicamente para descomponer tareas complejas en sub-tareas o para operaciones auxiliares que no deban usar otros objetos. En lenguajes como Java, C++ o PHP podemos marcar un método como `private` o `protected` para limitar su alcance. En Python de nuevo se utiliza la convención: un método cuyo nombre empieza con `_` indica "no lo uses desde fuera" (convención de protegido), y si empieza con `__` se considera privado, siendo renombrado internamente por Python. Por ejemplo, podríamos tener `def __calcular_saldo(self): ...` dentro de una clase cuenta bancaria para un método interno; el usuario de la clase no lo invocará directamente, en su lugar llamará a métodos públicos que internamente usan `__calcular_saldo`. En síntesis, la visibilidad de métodos permite a la clase exponer solo las operaciones seguras y pertinentes, ocultando los detalles de implementación o pasos intermedios (esto nuevamente es parte del encapsulamiento, tratado más abajo).

## Relación entre clase, objeto, atributos y métodos

Las clases, los objetos, sus atributos y métodos están estrechamente relacionados y se organizan de forma jerárquica. La **clase** define la estructura y el comportamiento: es decir, declara qué atributos (estado) y métodos (comportamiento) tendrán sus objetos. Un **objeto** (también llamado instancia) es la manifestación concreta de esa clase: cuando "instanciamos" una clase, creamos un objeto real en memoria que tiene sus propios valores de atributos y la capacidad de ejecutar los métodos definidos por la clase.

Cada objeto mantiene su **propio estado interno** a través de sus atributos. Objetos distintos de la misma clase tienen copias separadas de esos atributos, potencialmente con diferentes valores. Por ejemplo, si `Coche` define un atributo `color`, podemos crear dos objetos `Coche`: uno con `color="Rojo"` y otro con `color="Azul"`. Estos dos objetos comparten la misma definición (misma estructura de atributos y métodos), pero sus estados son independientes: cambiar el color de uno no afecta al otro. En código Python, podríamos ver algo así:

```python
coche1 = Coche("Ford", "Fiesta", "Rojo")
coche2 = Coche("Ford", "Fiesta", "Azul")
print(coche1.color)  # Rojo
print(coche2.color)  # Azul (independiente de coche1)
```

Como se aprecia, **cada instancia mantiene sus propios valores** de atributos, reflejando la independencia entre objetos creados a partir de la misma clase. Todos los objetos *comparten* la definición de clase (saben qué es `color` y que existe un método `acelerar()`, por ejemplo), pero cada uno tiene sus propios datos.

Los **métodos** actúan como comportamientos *generales* definidos en la clase, pero cuando se invocan en un objeto, operan sobre el estado particular de ese objeto. Esto significa que el mismo método puede dar resultados distintos según la instancia que lo ejecute. Por ejemplo, supongamos que la clase `Coche` tiene un método `acelerar()` que imprime un mensaje usando la marca y modelo del coche. Si `mi_coche` es un objeto con marca "Renault" y modelo "Clio", entonces `mi_coche.acelerar()` podría imprimir *"El Renault Clio está acelerando."*. Ahora, si `otro_coche` tiene marca "Toyota" y modelo "Yaris", al llamar `otro_coche.acelerar()`, el método usará los atributos de `otro_coche` y quizá imprima *"El Toyota Yaris está acelerando."*. El **código del método `acelerar` es único** (definido una vez en la clase), pero el contexto de cada objeto (`self`) hace que opere con datos diferentes en cada caso.

En otras palabras, la clase proporciona la **lógica común**, y cada objeto aporta su **estado propio** sobre el que se aplica esa lógica. Los métodos tienen implícitamente acceso a los atributos del objeto que los invoca, lo que vincula datos y comportamiento. Esta relación es el corazón de la POO: un objeto combina ciertos datos con las funciones capaces de manipular esos datos.

Otra forma de verlo es pensando en la **encapsulación** que ofrece la clase: dentro de cada objeto coexisten sus atributos (datos) y métodos (operaciones) que saben cómo usar esos datos. Por fuera, podemos considerar al objeto como una unidad con identidad propia, que responde a mensajes (llamadas de métodos) y puede cambiar su estado interno en respuesta. La clase define esa "unidad" y las reglas de interacción, pero es en los objetos donde realmente sucede la dinámica (almacenamiento de valores concretos y ejecución de métodos con efectos).

Como analogía final, volvamos al mundo real: pensemos en una clase como la receta de un pastel, que indica ingredientes (atributos) y pasos (métodos) para prepararlo. Un objeto sería un pastel específico que horneamos siguiendo esa receta. Cada pastel resultante tiene sus propios ingredientes concretos (cantidad de azúcar, sabor, etc. según la instancia) pero todos se hicieron siguiendo las mismas instrucciones. Cada pastel "sabe" cómo prepararse (porque la receta define el método), pero aplicará esas instrucciones con sus propias cantidades e ingredientes particulares. Así interactúan clase, atributos y métodos para darle vida a objetos concretos.

## Principios de diseño relacionados (encapsulamiento, cohesión, SRP, etc.)

Al diseñar clases en POO, no basta con hacerlas funcionar; también buscamos que su diseño sea **robusto, claro y mantenible**. Para ello, se aplican una serie de principios de diseño de software. A continuación, explicamos algunos de los más importantes y cómo se relacionan con clases, atributos y métodos:

* **Encapsulamiento:** Este principio establece que cada clase debe *encerrar* o *agrupar* tanto los datos como las operaciones que actúan sobre esos datos, y controlar el acceso a ellos. Dicho de otro modo, el encapsulamiento consiste en unir en la clase las características (atributos) y comportamientos (métodos) relacionados, formando una sola entidad lógica. Además, implica **ocultar la implementación interna** y exponer solo una interfaz limitada para interactuar con el objeto. La clase puede ser vista como una caja negra: uno conoce qué hace (métodos públicos), pero no necesariamente cómo lo hace internamente. Por ejemplo, al usar un televisor solo interactuamos con sus botones o el control remoto; no necesitamos saber qué ocurre en los circuitos internos para cambiar de canal o subir el volumen. De forma similar, gracias al encapsulamiento en software podemos **proteger los datos internos** y permitir acceso solo a través de métodos públicos seguros. Esto brinda dos ventajas: (1) evitamos que el estado interno sea modificado de manera inconsistente o indebida desde fuera (p. ej., podríamos validar en un setter que una edad nunca sea negativa antes de asignarla a un atributo), y (2) podemos cambiar la implementación interna de una clase sin afectar el código externo que la usa, siempre que mantengamos la misma interfaz. En la práctica, logramos encapsulación haciendo atributos privados y definiendo métodos públicos para accederlos o modificarlos de forma controlada. El encapsulamiento aumenta la **cohesión interna** de la clase (mantiene juntos datos y funciones relacionadas) y sienta las bases para reducir el acoplamiento con otras partes del programa.

* **Cohesión:** La cohesión mide qué tan enfocadas están las responsabilidades de una clase (o módulo). Una clase tiene **alta cohesión** cuando **todos sus atributos y métodos están fuertemente relacionados** entre sí y contribuyen a una única finalidad o funcionalidad principal. Por el contrario, una clase con responsabilidades muy dispares se considera de baja cohesión. Por ejemplo, si se crea una clase `Utilidades` que maneja lógica de interfaz gráfica *y* cálculo matemático *y* acceso a base de datos, tendría muy baja cohesión (hace muchas cosas inconexas). En cambio, si dividimos ese diseño en clases más especializadas (ej. una clase para la UI, otra para cálculos, otra para la base de datos), cada una será más cohesiva. **Alta cohesión** es deseable porque las clases simples y enfocadas son más fáciles de comprender, depurar y reutilizar. Además, suelen ser más fáciles de mantener: un cambio en requisitos afecta a una clase específica en lugar de a una mezcla de funcionalidades. De hecho, la cohesión está estrechamente ligada al principio de responsabilidad única (SRP) que veremos a continuación.

* **Principio de Responsabilidad Única (SRP):** El SRP (Single Responsibility Principle) postula que *cada clase debe tener una única responsabilidad o motivo de cambio*. Robert C. Martin lo resume así: **"Nunca debería haber más de una razón por la cual una clase deba cambiar"**. En otras palabras, una clase debe encapsular solo una parcela de lógica o funcionalidad. Si una clase atiende a múltiples propósitos, es probable que deba modificarse por motivos distintos y termine rompiendo este principio. Aplicar SRP típicamente nos guía a clases más pequeñas y altamente cohesionadas, donde todos sus miembros se orientan a cumplir ese único rol. Por ejemplo, podríamos tener una clase `GestorArchivos` cuya única responsabilidad sea leer/escribir archivos. Si además esta clase estuviera manejando la interfaz gráfica para seleccionar archivos, estaría teniendo dos responsabilidades (gestión de archivos y presentación UI), violando SRP. La solución sería separar: una clase se encarga de la lógica de archivos, otra de la interfaz. De esta forma, cada clase tiene un único motivo para cambiar (p.ej., la clase de archivos solo cambiaría si cambia la forma de acceder al sistema de archivos). Esto mejora la mantenibilidad y evita las "clases dios" o clases monolíticas que hacen de todo. Mantener cada clase enfocada en un solo propósito también facilita reutilizarla en distintos contextos.

* **Acoplamiento:** El acoplamiento se refiere al grado de dependencia o interconexión entre distintas clases o módulos. Un sistema bien diseñado busca **bajo acoplamiento**, es decir, que las clases interactúen entre sí de forma mínima y a través de interfaces claras. Si dos clases están fuertemente acopladas, un cambio en una podría requerir cambios en la otra; esto dificulta la extensión y el mantenimiento del código. Por ejemplo, si la clase A depende directamente de muchos detalles internos de la clase B, cualquier modificación en B podría romper a A. En cambio, si A y B se comunican a través de una interfaz abstracta o mínima, B puede cambiar internamente sin impactar a A. El acoplamiento suele ser inversamente proporcional a la cohesión: clases muy cohesivas tienden a tener menos dependencias con otras, porque hacen solo una cosa y se relacionan con pocas partes externas. Mediante encapsulamiento y SRP normalmente se logra **alta cohesión y bajo acoplamiento**, meta central del buen diseño OO. Un ejemplo práctico es dividir la lógica de negocio de la de interfaz gráfica: si están bien separadas en clases distintas y solo se comunican a través de métodos públicos necesarios, un cambio en la lógica de negocio no romperá la interfaz y viceversa (bajo acoplamiento). Clases con bajo acoplamiento pueden modificarse o reemplazarse con menor efecto dominó en el sistema.

En conjunto, estos principios (encapsulamiento, cohesión, responsabilidad única y bajo acoplamiento) contribuyen a un diseño orientado a objetos **más sólido y mantenible**. Gracias al encapsulamiento, los objetos actúan como unidades autónomas con interfaces bien definidas, permitiendo cambiar implementaciones internas sin afectar a quien las usa (principio de *abierto/cerrado*, Open/Closed). La cohesión y SRP nos aseguran clases claras y enfocadas, facilitando la comprensión y pruebas unitarias. Y minimizando el acoplamiento logramos que las distintas partes del sistema estén lo más independientes posible, reduciendo errores colaterales y favoreciendo la reutilización. No es coincidencia que estos conceptos sean promovidos por los principios **SOLID** de diseño de software, cuyo fin es lograr código de calidad: fácil de mantener, escalar y adaptar a cambios. Aplicándolos, obtenemos clases que funcionan juntas armoniosamente: cada una bien definida (cohesiva), protegida en su comportamiento interno (encapsulada), haciendo solo su trabajo (SRP) y comunicándose con otras de forma controlada (bajo acoplamiento).

## Cómo se implementa todo esto en Python: sintaxis, convenciones y ejemplos

Finalmente, veamos cómo llevar a la práctica las clases, atributos y métodos en **Python**, uno de los lenguajes más populares hoy en día. Python es multiparadigma pero ofrece soporte claro para POO. A continuación, definiremos una clase de ejemplo y analizaremos su sintaxis, siguiendo las convenciones típicas:

```python
class Coche:
    numero_ruedas = 4  # Atributo de clase (compartido por todos los Coche)
    
    def __init__(self, marca, modelo, color):
        # Atributos de instancia (propios de cada objeto)
        self.marca = marca
        self.modelo = modelo
        self.color = color
    
    def acelerar(self):
        print(f"El {self.marca} {self.modelo} está acelerando.")
    
    def frenar(self):
        print(f"El {self.marca} {self.modelo} está frenando.")
    
    @classmethod
    def obtener_ruedas(cls):
        """Método de clase: devuelve el número de ruedas estándar."""
        return cls.numero_ruedas
    
    @staticmethod
    def velocidad_maxima():
        """Método estático: devuelve una velocidad fija de referencia."""
        return 240
```

En este código, definimos la clase `Coche`. Veamos punto por punto:

* La línea `numero_ruedas = 4` declara un atributo de clase. Este valor reside en la clase `Coche` en sí y es *único* para todos los coches (todos comparten `numero_ruedas=4`).

* El método especial `__init__` es el **constructor** en Python. Se llama automáticamente al crear un nuevo `Coche`. Sus parámetros (`marca, modelo, color`) son los datos necesarios para instanciar un coche, y dentro de `__init__` asignamos esos valores a los atributos de instancia usando `self` (que representa el objeto que se está creando). Así, cada objeto `Coche` nuevo tendrá su propia `self.marca`, `self.modelo` y `self.color`.

* `acelerar` y `frenar` son **métodos de instancia**. Al definirse dentro de la clase, Python automáticamente hará que el primer parámetro sea `self`, representando al objeto desde el cual se invoque el método. En el cuerpo de estas funciones, usamos `self.marca` y `self.modelo` para acceder a datos del objeto y, en este caso, imprimir un mensaje. Son métodos típicos que operan sobre el estado del objeto que los llama.

* `obtener_ruedas` está precedido por `@classmethod`. Esto indica que es un **método de clase**. En lugar de `self`, recibe `cls` (la propia clase `Coche`). Dentro del método usamos `cls.numero_ruedas` para acceder al atributo de clase y retornarlo. Esto podría servir, por ejemplo, para consultar la configuración común de todos los coches. Los métodos de clase se pueden llamar tanto desde la clase (`Coche.obtener_ruedas()`) como desde una instancia (`mi_coche.obtener_ruedas()`), pero en cualquier caso el parámetro `cls` referirá a la clase `Coche`.

* `velocidad_maxima` está definido con `@staticmethod`. Es un **método estático**, lo que significa que no recibe `self` ni `cls` automáticamente. Es simplemente una función colocada dentro de la clase por organización. En el ejemplo, `velocidad_maxima()` devuelve un valor constante (digamos 240 km/h) sin depender de ningún dato de instancia ni de clase. Podemos invocarlo como `Coche.velocidad_maxima()` y obtener siempre el mismo resultado. Un método estático podría usarse para cálculos genéricos relacionados con los coches (por ejemplo, convertir unidades de velocidad) que no requieran información específica de un coche en particular.

**Instanciación y uso de objetos:** Para crear (instanciar) un objeto de una clase en Python, llamamos a la clase como si fuese una función, pasando los argumentos que el `__init__` espera. Por ejemplo:

```python
# Crear instancias de Coche
mi_coche = Coche("Renault", "Clio", "Blanco")
otro_coche = Coche("Toyota", "Yaris", "Azul")

# Acceder a atributos de instancia
print(mi_coche.marca)    # Renault
print(mi_coche.color)    # Blanco
print(otro_coche.color)  # Azul

# Invocar métodos de instancia
mi_coche.acelerar()      # El Renault Clio está acelerando.
otro_coche.frenar()      # El Toyota Yaris está frenando.

# Uso de atributo de clase (compartido)
print(Coche.numero_ruedas)    # 4
print(mi_coche.numero_ruedas) # 4  (las instancias lo comparten)

# Invocar método de clase y estático
print(Coche.obtener_ruedas())   # 4
print(Coche.velocidad_maxima()) # 240
```

Veamos qué ocurre en este código:

* Al hacer `Coche("Renault","Clio","Blanco")`, Python crea un nuevo objeto `Coche` y llama a `__init__` pasando `self` (el nuevo objeto) y los argumentos proporcionados. Dentro de `__init__`, se asignan `self.marca = "Renault"`, etc. El resultado es que `mi_coche` es un objeto con esos atributos inicializados. Del mismo modo, `otro_coche` tendrá sus propios valores. Ahora, **cada objeto tiene sus atributos poblados con datos distintos**.

* Podemos acceder a los atributos de instancia con la sintaxis `objeto.atributo` (por ejemplo `mi_coche.marca`). Esto nos devuelve el valor almacenado en ese objeto. Como vimos, `mi_coche.color` puede ser "Blanco" mientras `otro_coche.color` es "Azul", sin conflicto.

* Al invocar un **método de instancia** como `mi_coche.acelerar()`, internamente Python traduce esa llamada a `Coche.acelerar(mi_coche)`. Es decir, llama a la función `acelerar` definida en la clase, pasando el objeto `mi_coche` como `self`. Por eso, dentro de `acelerar`, cuando hacemos `print(f"El {self.marca} {self.modelo} está acelerando.")`, `self.marca` corresponde a `mi_coche.marca` ("Renault") y `self.modelo` a "Clio", produciendo *"El Renault Clio está acelerando."*. Si llamamos `otro_coche.frenar()`, ocurrirá análogamente: Python invoca `Coche.frenar(otro_coche)` y dentro del método `self` será `otro_coche`, usando sus valores ("Toyota Yaris"). Así, los métodos operan sobre los datos del objeto que los llama, cumpliendo el paradigma objeto->mensaje (el objeto sabe cómo ejecutar la acción con sus propios datos).

* El **atributo de clase** `numero_ruedas` es accesible tanto a través de la clase como de las instancias. `Coche.numero_ruedas` obviamente retorna 4. Curiosamente, `mi_coche.numero_ruedas` también retornará 4, porque al no encontrar `numero_ruedas` en el diccionario de atributos de `mi_coche`, Python va a buscarlo en la clase `Coche` y lo encuentra. Sin embargo, si intentáramos modificar `mi_coche.numero_ruedas` asignándole otro valor, estaríamos en realidad creando un **nuevo atributo de instancia** en `mi_coche` que oculta al de clase (no cambiaría el valor en la clase ni en otras instancias). Por tanto, para modificar un atributo de clase es recomendable hacerlo mediante la clase misma (`Coche.numero_ruedas = X`). En nuestro ejemplo no cambiamos `numero_ruedas` porque es una constante conceptual de los coches.

* En cuanto a los **métodos de clase y estáticos**, vemos que los llamamos desde la clase (`Coche.obtener_ruedas()`, `Coche.velocidad_maxima()`). El método de clase `obtener_ruedas` devuelve `cls.numero_ruedas`, que en este contexto es `Coche.numero_ruedas`, por lo que retorna 4 (coincidiendo con lo que imprimimos antes). Podríamos también llamar `mi_coche.obtener_ruedas()`: Python interpretará eso como llamada de método de clase pasando `cls = Coche` igualmente, así que retornaría lo mismo. El método estático `velocidad_maxima()` no depende de nada y simplemente devuelve 240 siempre, lo cual comprobamos en el print.

**Convenciones y detalles de Python:** A diferencia de lenguajes como Java, en Python no existen restricciones de visibilidad enforced por el lenguaje. **Todo atributo o método es públicamente accesible** por diseño. Sin embargo, siguiendo el espíritu del encapsulamiento, los desarrolladores Python utilizan las convenciones mencionadas: nombre iniciando con `_` para indicar "esto es interno, por favor no lo uses externamente" y con `__` para "estrictamente interno/privado". Por ejemplo, si en nuestra clase `Coche` quisiéramos que el atributo `color` fuera privado, podríamos cambiarlo a `self.__color` en `__init__` y ajustar los métodos. Desde fuera, intentar `mi_coche.__color` no funcionará (Python habrá *mangleado* el nombre a `_Coche__color` para esa instancia). Solo métodos de `Coche` podrían acceder a `__color`. Y si quisiéramos proveer lectura/escritura segura, añadiríamos, por ejemplo, `def get_color(self): return self.__color` y quizás `def repintar(self, nuevo_color): self.__color = nuevo_color` con la lógica necesaria.

En cuanto a **estilo**, Python recomienda (PEP 8) nombrar las clases usando **CamelCase** (PrimeraLetraMayúscula, e.j. `ClaseEjemplo`), y los nombres de métodos y atributos en **snake\_case** (minúsculas\_con\_guiones\_bajos). Además, por convención el primer parámetro de métodos de instancia se llama `self` (aunque técnicamente podría tener otro nombre, todos usan `self` por legibilidad). Estas convenciones hacen el código más legible y estándar dentro de la comunidad Python.

En resumen, Python implementa las clases de forma flexible: nos permite definir atributos de instancia y de clase fácilmente, métodos de instancia, de clase y estáticos con simples decoradores, e incluso simular privacidad mediante convenciones de nombres. Si bien Python no impone encapsulamiento mediante restricciones de acceso, es responsabilidad del desarrollador seguir las buenas prácticas para lograr diseños orientados a objetos limpios. El ejemplo de la clase `Coche` ilustra cómo una clase define un concepto (un coche con ciertas propiedades) y brinda funciones asociadas (métodos como acelerar/frenar), y cómo podemos crear múltiples objetos independientes de esa clase para modelar elementos reales. Cada objeto `Coche` maneja su propio estado (ej. cada coche tiene su propio color) mientras comparte la misma definición de comportamiento. Así, la teoría de clases, atributos y métodos se materializa en Python de forma directa, permitiendo **mapear problemas del mundo real a código** de manera natural, que es en esencia el poder de la Programación Orientada a Objetos.&#x20;
