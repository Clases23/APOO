
# Git y GitHub: Guía completa de control de versiones para principiantes

## ¿Qué es Git?

**Git** es un sistema de control de versiones distribuido, creado por Linus Torvalds en 2005 para el desarrollo del kernel de Linux. Nació de la necesidad de sustituir a BitKeeper (un VCS propietario que dejó de ser gratuito), estableciendo como objetivos la **velocidad**, la **simplicidad** en el diseño, soporte para desarrollo no lineal (muchas ramas) y un modelo **completamente distribuido**. Git es software libre y se ha convertido en el estándar de la industria para el versionado de código.

**¿Cómo funciona internamente?** A diferencia de otros VCS que almacenan los cambios como *diferencias* (deltas) sobre versiones anteriores, Git trata sus datos como una serie de **copias instantáneas** (*snapshots*) del proyecto en el tiempo. Cada vez que hacemos una confirmación (**commit**), Git guarda una *instantánea* del estado de **todos** los archivos en ese momento, en lugar de solo las diferencias. Si un archivo no ha cambiado, Git no lo duplica sino que crea un enlace interno al archivo idéntico ya almacenado anteriormente, aprovechando la redundancia para ser eficiente. Esto convierte esencialmente al repositorio en una especie de sistema de archivos miniatura que registra cada versión del proyecto.

Además, Git garantiza la **integridad** de la historia mediante sumas de comprobación (*checksums*). Internamente usa hashes SHA-1 de 40 caracteres para identificar de forma única cada commit u objeto, calculados a partir del contenido; es imposible alterar el contenido de un archivo o commit sin cambiar su hash, por lo que Git detectaría cualquier modificación corrupta. Cada objeto (commits, árboles, blobs) se referencia por su hash, no por nombre de archivo, lo que asegura integridad y trazabilidad.

Otra característica clave de Git es que casi todas sus operaciones son **locales**. El repositorio completo (toda la historia, commits y objetos) reside en la máquina del desarrollador, de modo que comandos como ver el historial, comparar cambios o crear ramas no requieren comunicación con un servidor remoto y ocurren *casi instantáneamente*. Esto permite trabajar sin conexión (hacer commits en un avión, por ejemplo) y luego sincronizar con el servidor cuando sea posible, a diferencia de sistemas centralizados donde la conexión es obligatoria para la mayoría de operaciones.

**Estados y área de preparación:** Git define tres *estados* fundamentales para los archivos: *modificado* (se ha cambiado el archivo en el directorio de trabajo, pero aún no preparado para commit), *preparado* o *staged* (el archivo ha sido añadido al área de preparación) y *confirmado* (el cambio ya se guardó en el historial del repositorio). El flujo de trabajo básico es: primero editamos archivos en el **directorio de trabajo**, luego añadimos los cambios al **área de preparación** (*staging area* o *index*) con comandos como `git add`, y finalmente con `git commit` registramos permanentemente una instantánea de esos cambios en el **directorio Git** (la base de datos interna). El área de preparación funciona como una zona intermedia donde reunimos exactamente qué cambios queremos incluir en el próximo commit. Gracias a ella, es posible confirmar solo ciertos cambios y dejar otros en espera, lo que otorga gran flexibilidad. En resumen, Git maneja sus datos de forma diferente a herramientas previas (como SVN o CVS) y esa filosofía de *instantáneas locales con hashes* le otorga velocidad, seguridad e incluso la base para potentes funcionalidades como las ramas ligeras.

## ¿Qué es GitHub?

**GitHub** es una plataforma en la nube basada en Git que permite **almacenar repositorios de código** y facilitar la colaboración entre desarrolladores. Mientras Git es la herramienta de control de versiones en sí (que puedes usar localmente para gestionar tu historial de cambios), GitHub ofrece un servicio web que hospeda repositorios Git *remotos* y agrega funcionalidades sociales y de gestión de proyectos sobre ellos. Es decir, puedes usar Git **sin** GitHub (por ejemplo, alojando tu propio servidor o usando otro servicio), pero GitHub potencia el uso de Git proporcionando una interfaz amigable y características adicionales orientadas al trabajo en equipo y la comunidad.

En GitHub cada proyecto se guarda en un **repositorio**. Al subir tu código a un repositorio en GitHub obtienes varias ventajas: es un respaldo remoto accesible desde cualquier lugar, puedes compartir tu trabajo públicamente o de forma privada, y otros desarrolladores pueden visualizarlo y colaborar enviando propuestas de cambio. GitHub está construido sobre Git, por lo que realiza seguimiento de todos los commits, ramas y archivos del mismo modo, pero añade capas para facilitar la interacción.

Algunas de las **funcionalidades principales** que ofrece GitHub son:

* **Control de código remoto:** hospeda repositorios Git centralizados. Permite *clonar* esos repos a tu máquina, *enviar* commits (push) o *traer* cambios (pull) fácilmente. Los repositorios pueden ser públicos (open source, visibles para todos) o privados (accesibles solo con permiso). Toda modificación enviada al repositorio se registra y es visible junto con los metadatos (autor, fechas, diferencias).
* **Bifurcaciones (*forks*):** GitHub facilita la creación de un **fork**, que es básicamente una copia de un repositorio en tu propia cuenta. Esto es muy usado en proyectos de código abierto: si quieres contribuir a un proyecto, puedes hacer *fork* del repositorio original (por ejemplo, de `usuario/proyecto` a `tuUsuario/proyecto`), y obtienes tu propia copia donde puedes hacer cambios libremente sin afectar al original. Luego puedes proponer que esos cambios se integren de vuelta (ver *pull requests*). Las bifurcaciones permiten experimentar o modificar proyectos ajenos manteniendo aislados los cambios hasta que se decida integrarlos.
* **Pull Requests (PRs):** Es una de las funciones estrella de GitHub para colaborar. Un *pull request* (también llamado *merge request* en otros entornos) es una **solicitud de incorporación de cambios**: le dice a los mantenedores del proyecto “quiero que revisen mis commits y, si todo está bien, los fusionen en su rama principal”. En GitHub, cuando abres un PR, se muestra claramente las diferencias de tu rama o fork con respecto a la rama destino, y ahí ocurre la revisión de código: los colaboradores pueden comentar líneas, proponer ajustes y aprobar o rechazar la integración. Es un flujo muy útil para mantener la calidad del código. Por ejemplo, tras hacer cambios en una rama llamada `feature/nueva-func`, abres un PR hacia `main` en la interfaz de GitHub; otros revisan el código, hacen comentarios, quizás se realizan cambios adicionales, y cuando está listo, el PR se *mergea* (fusiona) incorporando esos commits a la rama principal. Los pull requests quedan registrados, de modo que en el futuro puedes ver qué se discutió o por qué se hizo cierto cambio.
* **Issues (incidencias):** GitHub incluye un sistema de seguimiento de incidencias o *issues*. Son básicamente tarjetas donde se describen bug reports, solicitudes de nuevas funcionalidades, o cualquier tarea/discusión relacionada con el proyecto. Los issues permiten conversación (comentarios), etiquetado, asignación de responsables, y otros metadata (como estado abierto/cerrado). Esto ayuda a organizar el trabajo y a que la comunidad participe reportando problemas o proponiendo mejoras. Es muy común en proyectos open source manejar todo su *roadmap* o backlog mediante issues.
* **Wiki y documentación:** Cada repo puede tener un Wiki asociado para documentación del proyecto. También es habitual que el archivo README.md del repositorio (visible en la página principal del repo) sirva como documentación inicial.
* **Integraciones y otras características:** GitHub ofrece *“social coding”* en el sentido de que puedes seguir a otros desarrolladores, “estrella” (marcar como favorito) repositorios, ver estadísticas de contribución, etc. A nivel de proyecto, hay herramientas como el tablero de *Projects* (tipo Kanban) para organización de tareas, gestión de versiones (lanza *Releases* que adjuntan changelogs y binarios), acciones automatizadas mediante **GitHub Actions** (plataforma de CI/CD integrada) y más.

En resumen, **Git** es la herramienta que lleva el registro de los cambios en el código, mientras que **GitHub** es un servicio que utiliza Git bajo el capó y añade facilidades para colaborar en código de forma centralizada. Existen plataformas similares a GitHub, como GitLab o Bitbucket, con diferencias en enfoque y características, pero para un principiante es suficiente entender que GitHub = alojamiento de repositorios Git + un ecosistema de colaboración en torno a ellos.

*(Nota: Aunque hablemos de GitHub, muchos conceptos aplican igual en GitLab, Bitbucket u otros. Por ejemplo, **forks**, **pull requests** (a veces llamados merge requests) e **issues** son ideas generales de colaboración con Git, implementadas de forma similar en distintas plataformas.)*

## Ventajas del control de versiones

Adoptar un sistema de control de versiones como Git conlleva numerosos **beneficios** en el desarrollo de software:

* **Historial completo y recuperable:** el código fuente tiene memoria. Cada cambio queda registrado en el historial con su autor, fecha y descripción. Esto permite ver qué se hizo, cuándo y por quién, facilitando depuración y auditoría. Si algo sale mal, podemos **revertir** el proyecto a cualquier versión anterior en cualquier momento, recuperando un estado estable previo fácilmente. Esta habilidad de *"viajar en el tiempo"* da gran confianza para experimentar, pues sabemos que siempre es posible deshacer cambios o comparar versiones antiguas y nuevas.
* **Colaboración simultánea sin pisarse el trabajo:** múltiples desarrolladores pueden trabajar a la vez *en el mismo código* sin que unos sobrescriban los cambios de otros. Cada cual desarrolla en su copia/local y luego integra los cambios. El VCS se encarga de **combinar las contribuciones** inteligentemente y resaltar conflictos cuando el mismo fragmento de código fue editado por dos personas. Esto elimina la necesidad de coordinar “tú primero, luego yo” o enviar archivos por email. Git incluso permite ramas paralelas para que cada uno trabaje aislado y luego fusionar todo, conservando las modificaciones de todos.
* **Mejora en la organización y trazabilidad:** el control de versiones impone una estructura clara al desarrollo. Por ejemplo, se pueden crear ramas para diferentes características o releases, manteniendo ordenado el flujo de trabajo. Cada commit lleva un mensaje descriptivo, lo que documenta el porqué de los cambios. Herramientas como Git también permiten etiquetar commits importantes (p. ej. versiones de lanzamiento), facilitando localizar la versión 1.0, 2.0, etc., o extraer parches específicos. En esencia, el proyecto tiene una **línea de tiempo documentada**. Esto ayuda enormemente en mantenimiento, ya que puedes entender la evolución del software y las razones detrás de cada modificación.
* **Integración con procesos de CI/CD y automatización:** un VCS permite automatizar tareas cada vez que se cambia el código. Por ejemplo, es común que al hacer push de commits a una rama principal, se dispare automáticamente un conjunto de **pruebas** o un proceso de **build** e incluso un **despliegue** continuo. Esto es posible porque el repositorio actúa como la fuente única de verdad del código: las herramientas de integración continua detectan los nuevos commits y pueden operar con ellos (ejecutar pruebas, analizar calidad de código, compilar artefactos, desplegar a servidores, etc.). Así, el control de versiones se convierte en el corazón del pipeline de DevOps, acelerando entregas y asegurando consistencia (ej.: “si pasó las pruebas en esta commit, sabemos que esa versión es válida para producción”).
* **Protección ante pérdidas y respaldo:** con un VCS distribuido como Git, cada colaborador tiene una copia completa del repositorio (con toda la historia). Esto en la práctica es un **respaldo**: si el servidor remoto falla, cualquier clon local tiene el proyecto íntegro y puede restaurarse. Incluso en sistemas centralizados, el hecho de hacer commits frecuentes reduce la posibilidad de perder trabajo grande: cada cambio importante ya quedó guardado en la historia. Adicionalmente, las plataformas remotas como GitHub añaden capa de seguridad (respaldo en la nube, redundancia) y control de acceso: puedes gestionar quién tiene permiso de leer o escribir en cada rama, proteger ramas para que cierto código solo cambie vía revisión, etc., elevando la seguridad del proceso de desarrollo.
* **Fomenta buenas prácticas de desarrollo:** usar control de versiones naturalmente conduce a mejorar la disciplina en la gestión de código. Por ejemplo, escribir buenos mensajes de commit, agrupar cambios lógicamente, usar ramas temáticas, revisar el código en equipo mediante pull requests, etc., son hábitos que surgen del uso de estas herramientas. También reduce significativamente errores humanos (¿quién no ha perdido código por sobreescribir un archivo accidentalmente?). Con Git, cada cambio está registrado y nada se pierde “sin querer”. Todo ello redunda en software de más calidad. De hecho, muchos equipos no podrían coordinarse sin un VCS, especialmente en proyectos grandes con decenas de desarrolladores.

En resumen, un sistema de versionado como Git brinda un entorno seguro para el código: es como un *deshacer/rehacer* infinito, un registro histórico, un canal de colaboración y un pilar para la integración continua, todo en uno. Su uso se considera esencial en prácticamente cualquier desarrollo profesional, por las ventajas mencionadas.

## Principales comandos de Git (explicados con ejemplos)

A continuación se listan los **comandos básicos de Git** que todo desarrollador debe conocer, junto a una breve explicación y ejemplo:

* **`git init`:** inicializa un nuevo repositorio de Git en el directorio actual. Es el comando para empezar a versionar un proyecto existente (crea un subdirectorio `.git` con la base de datos de commits, ramas, etc.). <br> *Ejemplo:* Situados dentro de la carpeta de tu proyecto, ejecuta `git init` para convertirla en un repositorio Git (inicialmente sin commits hasta que hagas el primero).
* **`git clone`:** clona (copia) un repositorio Git remoto existente hacia tu máquina. Este comando descarga todo el historial de commits y archivos. Es la forma más típica de obtener una copia de un proyecto hospedado en algún servidor (GitHub, GitLab, etc.). <br> *Ejemplo:* `git clone https://github.com/usuario/nombre-repo.git` creará una carpeta local con el contenido del repositorio indicado, incluyendo todos sus commits y ramas.
* **`git status`:** muestra el estado de la rama actual (working directory y staging area). Te indica qué archivos han sido modificados, cuáles están en el área de preparación (*staged*) listos para commit, cuáles no están siendo seguidos (*untracked*), si la rama local está adelantada/atrasada respecto al remoto, etc. Es muy útil antes de hacer commit para ver qué cambios van a incluirse. <br> *Ejemplo:* tras editar algunos archivos, `git status` puede decir: *"modified: main.py (no staged for commit)"* indicando que *main.py* cambió pero no se ha hecho `git add` aún.
* **`git add`:** añade cambios al área de **preparación** (staging). Se usa después de modificar o crear archivos, para incluirlos en el próximo commit. Puedes añadir archivos individuales o todos a la vez. *Importante:* hasta que no hagas `git add`, los cambios no forman parte del commit pendiente. <br> *Ejemplos:* `git add archivo.txt` prepara solo ese archivo; `git add .` prepara todos los archivos modificados en el directorio actual; `git add -A` prepara **todos** los cambios (renombres, borrados, etc.) en el repositorio.
* **`git commit`:** registra definitivamente los cambios preparados en el historial del repositorio (crea un nuevo *commit*). Es como hacer una "foto" de tus archivos en ese punto del tiempo. Por convención, cada commit lleva un mensaje descriptivo usando la opción `-m`. Un commit solo afectará a los archivos que se habían añadido al staging area previamente (con `git add`). Tras el commit, el staging area queda vacío nuevamente (hasta nuevos cambios). <br> *Ejemplo:* `git commit -m "Implementa la función de login"` creará un commit con ese mensaje. Este commit incluirá todos los cambios que estén *staged*. Si olvidaste algún cambio, Git te avisará que hay archivos modificados no incluidos.
* **`git log`:** muestra el **historial de commits** de la rama actual (por defecto) o de todo el repositorio. Lista los commits más recientes primero, con su hash, autor, fecha y mensaje. Tiene muchas opciones para formatear la salida o filtrar por autor, fecha, etc. <br> *Ejemplo:* `git log --oneline --graph` muestra un historial resumido (un hash corto y mensaje por commit) dibujando además el gráfico de ramas/fusiones en ASCII.
* **`git branch`:** permite gestionar **ramas**. Usado sin parámetros, lista las ramas existentes en el repositorio y marca en cuál estás actualmente. Con opciones, sirve para crear o eliminar ramas. <br> *Ejemplos:* `git branch nueva-rama` crea una nueva rama llamada “nueva-rama” (a partir de la rama actual, en la misma posición de commit); `git branch -d feature-x` borra la rama “feature-x” (si ya fue fusionada); `git branch -m nombre-viejo nombre-nuevo` renombra una rama.
* **`git checkout`:** se utiliza principalmente para **cambiar de rama** (activar una rama distinta en tu directorio de trabajo). Al hacer checkout de una rama, Git actualiza los archivos en tu carpeta al estado correspondiente a esa rama. También sirve para descartar cambios en archivos o incluso para extraer versiones específicas de un archivo desde la historia. En versiones modernas de Git, el comando `git switch` es una alternativa más semántica para cambiar de rama, pero `checkout` sigue muy usado. <br> *Ejemplos:* `git checkout main` cambia a la rama *main*; `git checkout -b fix-bug` **crea** una nueva rama *fix-bug* y a la vez te mueve a ella (el `-b` es atajo para crear+checkout). Si tenías archivos sin commitear al cambiar de rama, Git te avisará o impedirá el cambio (a menos que hagas *stash* o commit de esos cambios antes).
* **`git merge`:** fusiona una rama en la rama actual. Después de integrar commits con `git pull` o de terminar una feature en una rama separada, este comando combina las historias. Git intentará auto-merge; si hay conflictos, te lo indicará para resolución manual (ver sección de *conflictos* más abajo). <br> *Ejemplo:* estando en la rama *main*, `git merge desarrollada` incorporará todos los commits de la rama *desarrollada* en *main*, creando un commit de merge si no puede ser avance rápido. Tras un merge exitoso, suele borrarse la rama fusionada si ya no es necesaria (`git branch -d desarrollada`).
* **`git pull`:** actualiza la rama actual con los cambios del remoto. Es básicamente una combinación de `git fetch` (traer commits nuevos del servidor) + `git merge` (integrarlos en tu rama) en un solo paso. Después de colaborar en GitHub, por ejemplo, usar `git pull` garantiza que tienes los últimos commits que otros subieron. <br> *Ejemplo:* `git pull origin main` traerá del remoto llamado *origin* los commits en la rama *main* y los fusionará en tu *main* local. Si no has hecho commits locales divergentes, suele ser un *fast-forward* limpio; de lo contrario, puede generar un commit de merge o indicar conflictos a resolver.
* **`git push`:** envía tus commits locales al repositorio remoto. Es la contraparte de `pull`. Cuando has hecho commits en tu rama local y quieres publicarlos en GitHub (u otro servidor), `git push` subirá esas referencias. Normalmente se especifica el remoto y la rama de destino. Tras un push, los demás colaboradores podrán hacer pull de esos cambios. <br> *Ejemplo:* `git push origin main` sube los commits de tu rama *main* local al *main* del remoto *origin* (por convención, *origin* es el nombre que Git asigna automáticamente al clonar, apuntando al repo original). Si esa rama remota no existía (por ejemplo, primera vez que subes una nueva rama), Git te indicará que la cree: se suele usar la opción `-u` la primera vez (ej: `git push -u origin nueva-rama`) para establecer *upstream* y luego solo `git push` bastará.

Estos comandos cubren el ciclo básico de usar Git día a día. Por supuesto, Git tiene muchos más comandos y opciones: por ejemplo, `git remote` para gestionar las URL de remotos, `git tag` para etiquetar commits importantes (versiones), `git stash` para guardar cambios temporales, comandos de inspección como `git diff` (ver diferencias) o `git show`, y comandos de *deshacer* (`git reset`, `git revert`, etc.). A medida que ganes experiencia, irás conociendo los más avanzados, pero los de arriba son suficientes para comenzar a trabajar en la mayoría de proyectos.

*(Truco: Git tiene mucha documentación incorporada. Puedes usar `git help <comando>` para leer sobre cualquier comando, o `git help -g` para ver guías conceptuales. Además, existen *cheat sheets* (hojas de referencia) muy útiles que resumen estos comandos básicos.)*

## Flujos de trabajo recomendados con Git

Git es muy flexible y admite diferentes **estrategias de ramificación y flujo de trabajo**. Dependiendo del tipo de proyecto y equipo, se han popularizado ciertas metodologías para organizar cómo se usan las ramas y cómo se hacen los lanzamientos. Vamos a describir tres de los flujos más conocidos: **Git Flow**, **GitHub Flow** y **Trunk-Based Development**, con sus características principales.

### Git Flow

Este modelo, propuesto por Vincent Driessen en 2010, define una estrategia robusta basada en ramas de larga duración para gestionar proyectos con ciclos de lanzamiento definidos (por ejemplo, software que tiene versiones mayores, releases planificadas cada cierto tiempo, etc.). En Git Flow se usan dos ramas principales permanentes:

* **`main`** (a veces llamada `master` en la literatura original): representa el código de producción estable. Solo contiene commits que han sido lanzados (deploy) o están listos para lanzarse. Cada versión final se marca con una etiqueta en esta rama.
* **`develop`**: es la rama de integración de desarrollo. Aquí van cayendo todos los cambios de funcionalidades una vez completados y probados, preparando lo que será la siguiente versión estable.

A partir de esas ramas base, Git Flow define ramas de soporte de corta duración para organizar el trabajo:

* **Ramas de *feature* (funcionalidad)**: se crean desde `develop` para desarrollar nuevas características o cambios grandes. Por convención suelen nombrarse `feature/nombre-descripcion`. Varios developers pueden trabajar en distintas features en paralelo, cada uno en su rama. Cuando una feature está lista, se fusiona de vuelta a `develop`.
* **Ramas de *release* (lanzamiento)**: cuando la rama `develop` tiene suficientes cambios para una versión, se crea una rama `release/x.y` desde `develop` y en ella se realizan únicamente tareas de estabilización: corrección de últimos bugs, cambios menores de configuración, documentación de la release, etc. Sirve para preparar una versión final sin frenar el flujo de `develop` (que podría seguir recibiendo commits de la siguiente versión en paralelo). Al terminar, esta rama *release* se fusiona tanto a `main` (marcando el release) **como** de vuelta a `develop` (para no perder esos commits de fixes).
* **Ramas de *hotfix* (urgencias)**: si se descubre un bug crítico en producción, se crea una rama desde `main` (que refleja el estado en producción) para arreglarlo inmediatamente. Una vez arreglado, esa rama se fusiona tanto a `main` (para desplegar el fix) como a `develop` (para que el arreglo también esté en la siguiente versión en desarrollo). Las ramas hotfix suelen nombrarse `hotfix/descripcion`.

**Ventajas:** Git Flow aporta un **flujo estructurado** y controlado. Separa claramente el código en desarrollo del código en producción, lo que ayuda a mantener la estabilidad en `main`. Promueve el uso de **pull requests** y revisiones de código, ya que generalmente las fusiones hacia `develop` o `main` se hacen mediante PR para que algún responsable las apruebe. También facilita mantener múltiples versiones: por ejemplo, se puede tener una rama `hotfix` derivada de la versión en producción mientras en develop está la siguiente versión mayor, sin interferir. Es ideal para proyectos que lanzan versiones "grandes" infrecuentes o con múltiples colaboradores donde se necesita coordinar qué entra en cada release.

**Desventajas:** En entornos ágiles con despliegues continuos, Git Flow puede resultar **pesado o lento**. El requerir fusiones intermedias (features -> develop -> release -> main) y aprobaciones puede entorpecer la rapidez del equipo. También, al mantener **ramas de larga vida** (una feature que tarda semanas en integrarse), aumenta la probabilidad de conflictos al fusionar porque `develop` pudo cambiar bastante durante ese tiempo. Esto puede derivar en merges complicados. Otro punto es que los **releases son más “grandes” y espaciados** en el tiempo, no encajando con filosofías DevOps de entregar continuamente. De hecho, en los últimos años Git Flow ha perdido popularidad en favor de flujos más simples (ver trunk-based) orientados a CI/CD rápido. Aun así, Git Flow sigue siendo una estrategia válida, sobre todo para equipos que versionan su software en lanzamientos formales (por ejemplo, aplicaciones de escritorio, librerías que publican versiones, etc.) y quieren un control riguroso de qué código entra a producción.

*(Nota: Existe una extensión de línea de comandos llamada `git-flow` que automatiza la creación de estas ramas y merges con comandos simplificados, pero su uso no es obligatorio para implementar el modelo.)*

### GitHub Flow

Es un flujo de trabajo propuesto por GitHub pensado para ser **más simple y ágil** que Git Flow. Se enfoca en *ramas cortas* y despliegues muy frecuentes, ideal para proyectos web o servicios donde desplegar muchas veces al día es factible. En GitHub Flow **solo existe una rama principal** (habitualmente `main`), y todas las características se desarrollan en ramas secundarias que se fusionan a `main` lo antes posible.

Las reglas clave del GitHub Flow son:

1. **Main siempre desplegable:** La rama `main` debe reflejar código listo para producción en todo momento. Puedes desplegar cualquier commit de main con confianza. Esto implica que no se hacen commits directos en main con código a medio hacer; primero va en rama separada.
2. **Ramas de feature breves:** Para cualquier trabajo nuevo (feature o fix), se crea una rama desde `main` con un nombre descriptivo (por ejemplo, `mi-feature` o `fix-404-error`). En esa rama se van haciendo commits regularmente, y también se pueden publicar al remoto para compartir el progreso.
3. **Pull request para fusionar:** Cuando quieres integrar la rama (ya sea porque terminaste la feature o necesitas ayuda/revisión), abres un **pull request** en GitHub. Ahí otros revisan el código, ejecutan pruebas si aplican (la integración con CI corre tests en el PR), discuten cambios, etc.
4. **Revisión y merge:** Al ser aprobado el PR por el equipo (o por quien esté encargado), se realiza la **fusión a `main`** (merge). Normalmente GitHub te deja hacer “Merge pull request” directamente desde la interfaz una vez está aprobado y sin conflictos. Este merge añade los commits de la feature a main (ya sea con merge commit o squash, depende de la preferencia del equipo).
5. **Despliegue inmediato:** Dado que *main* siempre está estable, cada merge en main puede desplegarse de inmediato. De hecho, muchas organizaciones automatizan que cada push a main despliegue en producción (tras pasar tests). Esto asegura entregas contínuas.

**Características:** GitHub Flow **no tiene una rama “develop”** separada; la integración es continua directamente a main. Esto simplifica la gestión de ramas y elimina pasos intermedios. Todo cambio pasa por PR, lo que mantiene la calidad (otra persona revisa) pero sin la sobrecarga de muchas ramas largas. Es particularmente útil en equipos que hacen *deploy* diario o en cada merge. Al no haber releases “grandes”, se entrega valor continuamente en pequeñas porciones.

Un ejemplo de GitHub Flow típico: Imagina que estás trabajando en agregar una nueva sección a un sitio web. Creas la rama `feature/section-about`, haces varios commits allí. Cuando está lista (o quieres feedback anticipado), abres un PR hacia main. Tus compañeros revisan el código, proponen algún cambio menor. Tú haces nuevos commits en la misma rama (que quedan incluidos en el PR automáticamente). Cuando todos están satisfechos y los tests pasan, se aprueba y se fusiona a main. Inmediatamente, una acción de despliegue publica esos cambios en producción. Todo este ciclo quizá ocurrió en 1-2 días o menos. Mientras tanto, otra persona hizo lo mismo con otra feature distinta. Ninguno bloqueó al otro porque trabajaron en ramas separadas y ambos PR se fusionaron en cuanto estuvieron listos.

**Ventajas:** muy **ligero y rápido**. Promueve integraciones tempranas y frecuentes, reduciendo la probabilidad de conflictos enormes (porque las ramas viven poco). Main siempre está listo para salir a producción, alineado con prácticas de *DevOps* modernas. Es fácil de entender: básicamente crear rama para todo cambio y usar PR para revisar.

**Desafíos:** requiere que el equipo adopte disciplina de *“siempre verde”*, es decir, cuidar la calidad de main con integraciones pequeñas. Si no hay pruebas automatizadas suficientes, existe riesgo de introducir bugs en producción con tanta frecuencia, por lo que suele complementarse con CI/CD robusto. Además, funciones grandes deben dividirse en entregas pequeñas o esconderse tras *feature flags* si no se pueden completar rápido, ya que la idea es no tener ramas largas. GitHub Flow encaja mejor en proyectos donde la entrega continua es prioridad (ej: aplicaciones web SaaS) y menos en proyectos con releases paquetizadas para clientes (ej: un software de escritorio versionado, donde quizás se prefiera Git Flow o similar).

En resumen, **GitHub Flow** es iterativo y continuo: “haz cambios en una rama aislada → mezcla a main tras revisión → despliega”, repitiendo este ciclo rápido. Es el flujo que GitHub *en sí* usa para desarrollar su plataforma y lo recomiendan para muchos equipos ágiles.

### Trunk-Based Development (Desarrollo basado en tronco)

El desarrollo *basado en tronco* es más una filosofía general que un flujo rígido, pero se refiere a mantener **una sola rama principal (trunk)** donde todos colaboran integrando cambios continuamente, evitando ramas de larga duración por completo. Es considerado hoy en día una de las **mejores prácticas** para lograr integración y entrega continua (*CI/CD*) efectiva.

En trunk-based, los desarrolladores *fusionan pequeñas actualizaciones con frecuencia en el "tronco" principal* (es decir, commits pequeños, múltiples veces al día idealmente, directamente a `main`). No existen ramas persistentes de desarrollo vs producción: **solo una rama central**. Las ramas de apoyo son mínimas: a lo sumo ramas cortas para una tarea puntual, que pueden vivir unas horas o un día, y se integran de vuelta al trunk rápidamente. En muchos casos extremos ni siquiera se crean ramas temporales, sino que se comitea directamente en main código ya listo (muchos equipos sí crean ramas de feature pero las mergean el mismo día).

Las **claves del trunk-based**:

* Integración continua **real**: cada commit que se agrega a trunk gatilla el pipeline de CI; si algo falla, se arregla de inmediato. La rama principal debe estar casi siempre en estado saludable (tests pasando) para poder desplegarse en cualquier momento.
* **Sin divergencias prolongadas:** dado que nadie trabaja en ramas aparte por mucho tiempo, no hay “drift” de código ni grandes sorpresas al fusionar. Se evitan los merges grandes acumulados (que suelen causar conflictos). “Integrar temprano y a menudo” es el lema.
* **Feature flags:** Dado que puede haber funcionalidades en desarrollo que tardan días o semanas, ¿cómo se integran diario sin que se activen incompletas? La respuesta suele ser usar *flags* o *toggles*: es decir, incorporar el código al trunk pero “apagado” hasta que esté listo para uso. Así, trunk contiene código de features en curso, pero inactivo en producción hasta su finalización, evitando ramas largas. Una vez lista la feature, se enciende el flag (lo cual es un cambio pequeño).
* **Lanzamiento bajo demanda:** Como trunk siempre tiene lo último del código funcionando, el equipo puede decidir desplegar en cualquier momento (a veces *varias veces al día*). Esto da mucha agilidad de negocio (si hoy se termina una mejora, hoy mismo puede estar en prod). De hecho, trunk-based es típico en compañías que hacen *release* continuo, a diferencia de GitFlow que espera releases agrupados.

**Beneficios:** maximiza la **eficiencia y velocidad**. No hay sobrecarga de gestionar muchas ramas, ni PR que se quedan colgando mucho tiempo: todos contribuyen al mismo flujo principal. Se eliminan prácticamente los conflictos complejos porque si dos personas editan partes cercanas, lo sabrán *hoy*, no dentro de un mes al combinar enormes ramas. Siempre se trabaja sobre la última versión del código, lo que reduce duplicación de esfuerzo. Este modelo coincide con prácticas DevOps de alto desempeño, y estudios (por ejemplo, el *Accelerate: State of DevOps*) han encontrado que los equipos que lo adoptan logran menor tiempo de entrega y menos errores en producción, gracias a la retroalimentación rápida.

**Requisitos/Desafíos:** trunk-based **requiere madurez en el equipo y en la automatización**:

* Es esencial tener un buen conjunto de **pruebas automatizadas** (unitarias, integrales) que se ejecuten rápido para cada commit. Así se garantiza que lo que entra a main está suficientemente probado. Sin esta red de seguridad, integrar código tan rápidamente sería arriesgado.
* Se necesita **integración continua automatizada**: servidor(es) de CI que hagan build/test en cada commit, e idealmente despliegues automatizados. También prácticas de monitoreo y alertas robustas (si algo falla en prod se detecta enseguida).
* Los desarrolladores deben hacer **commits pequeños y frecuentes** de código funcional (no romper la build), y colaborar estrechamente. Esto implica a veces partir historias de usuario muy grandes en entregas más pequeñas incrementales, o usar los mencionados *feature flags* para código incompleto.
* En cuanto a control, trunk-based a veces se complementa con revisiones de código ligeras (por ejemplo, via herramientas de pre-commit o pareo) ya que no siempre hay PR formales para cada cambio como en GitHub Flow. Sin embargo, muchos equipos trunk-based sí usan pull requests pero de ciclo muy corto (minutos/horas) o prácticas como desarrollo *en pareja* para mantener calidad.

En la práctica, **Trunk-Based Development** es la estrategia adoptada por proyectos que buscan **deploy continuo** con mínima fricción. Google, por ejemplo, ha usado durante años un modelo parecido (un solo trunk para miles de desarrolladores, con herramientas de bots y tests masivos para mantener la estabilidad). Atlassian recomienda trunk-based como la mejor opción para equipos que implementan DevOps y entrega continua, considerando a GitFlow más “legacy”. En resumen: trunk-based sacrifica la segregación rígida de trabajo (no develop vs main, no releases aislados) en favor de la **agilidad máxima**, apoyándose fuertemente en automatización para no comprometer la calidad.

**¿Cuál flujo usar?** No hay una respuesta única; depende del contexto:

* *Git Flow* puede convenir si tienes un ciclo de releases versión 1.0, 2.0… y quieres control estricto de qué entra en cada versión, o un equipo grande donde asignar roles de “gatekeeper” de código.
* *GitHub Flow* es genial para startups y proyectos web que despliegan continuamente y prefieren simplicidad con revisión vía PR.
* *Trunk-based* suele verse en compañías de producto digital con cultura DevOps muy madura, donde la prioridad es minimizar el tiempo de entrega y se confía en la automatización y en el equipo para mantener todo funcionando en main.

Incluso hay flujos híbridos; por ejemplo *GitLab Flow* combina ideas de GitHub Flow con ramas por entornos (preproducción/producción). Lo importante es que el equipo entienda las reglas de su flujo y las siga disciplinadamente. Como desarrollador, te conviene conocer estos modelos, pues en distintas organizaciones te encontrarás con alguno de ellos.

## Trabajo colaborativo: branching, merges y resolución de conflictos

Una de las grandes fortalezas de Git para el trabajo en equipo es el uso de **ramas**. Una *rama* (branch) representa una línea de desarrollo independiente, con su propio historial de commits, que parte de un punto común con otras ramas. Por defecto, cuando inicializas un repo Git tienes una rama (usualmente llamada `main` o `master`). Pero al colaborar, es habitual que cada desarrollador cree ramas adicionales para trabajar en ciertas tareas o features, de modo que no interfieran con la rama principal hasta estar listas. Por ejemplo, podríamos tener la rama `login-feature` donde Alice desarrolla la funcionalidad de login, mientras Bob trabaja en la rama `payment-api` para integrar pagos. Cada rama contiene commits específicos a su objetivo.

El proceso típico colaborativo sería: cada quien desarrolla en su rama local, hace múltiples commits, y cuando considera que su trabajo está listo para integrar, **fusiona** (*merge*) su rama en la rama principal (u otra rama de integración como `develop` según el flujo). La fusión combina los historiales de ambas ramas. Git intentará hacerlo automáticamente: calculará el **ancestro común** de las ramas y aplicará los commits de la rama de tema sobre la base de la rama destino. Si la rama a fusionar es simplemente una continuación lineal (caso de un fast-forward), Git avanza el puntero y listo; si ha divergido, hará una fusión de tres vías creando un commit de merge para unir ambas líneas de historia.

En proyectos con muchos colaboradores, a veces se acumulan varias ramas pendientes de integrar. Es buena práctica integrar con frecuencia para evitar que una rama quede muy desactualizada respecto a la principal. También es común que la integración se gestione con Pull Requests, de forma que la fusión incluya revisión de código (como describimos en GitHub Flow). En cualquier caso, Git es eficiente manejando merges: **identifica automáticamente el mejor ancestro común** y aplica solo los cambios nuevos de cada lado. La mayoría de fusiones menores las resuelve sin intervención humana.

Sin embargo, pueden ocurrir **conflictos de fusión** (*merge conflicts*). Un **conflicto** surge si Git no puede determinar cómo combinar los cambios de dos ramas. Esto sucede típicamente cuando las dos ramas modificaron la **misma porción de código en el mismo archivo** de maneras distintas. Git se queda sin saber cuál versión es la correcta o cómo mezclarlas. Cuando detecta un conflicto, Git **detiene el proceso de merge** justo antes de crear el commit de fusión, y te notifica qué archivos tienen conflictos. Es entonces tarea del desarrollador resolverlos manualmente.

¿Cómo se ve un conflicto? Git marca en el propio archivo las secciones conflictivas con unos **marcadores estándar**: `<<<<<<< HEAD` y `>>>>>>> nombre_rama` delimitan las dos variantes, separadas por `=======`. Por ejemplo, tras un `git merge` podría aparecer en un archivo:

```
<<<<< HEAD
<div id="footer">Contacto: email.soporte@miempresa.com</div>
=======
<div id="footer">Please contact us at support@miempresa.com</div>
>>>>> iss53
```

Esto indica que en la versión de la rama actual (HEAD) esa línea está en español, mientras que en la rama `iss53` está en inglés, y Git no pudo decidir cuál dejar. La solución la decide un humano: podríamos optar por una de las dos, o combinar ambas (e.g. traducir a "please contact us at [email.soporte@miempresa.com](mailto:email.soporte@miempresa.com)").

El **proceso de resolución** consiste en editar los archivos conflictivos para dejarlos como deberían quedar, eliminando los marcadores `<<<<<<<`, `=======`, `>>>>>>>` una vez elegida la versión correcta. Tras editar cada conflicto y guardar los archivos, se utiliza `git add <archivo>` para *marcar como resuelto* ese archivo (Git lo saca del estado de "unmerged"). Cuando todos los conflictos están resueltos y añadidos, se finaliza la fusión ejecutando `git commit` (este commit será el merge commit si todo quedó bien). Git incluirá por defecto un mensaje de commit indicando que fue una merge con conflictos resueltos manualmente.

Algunas recomendaciones en colaboración para minimizar conflictos:

* Comunicar con el equipo qué partes del código se está tocando; a veces dividir responsabilidades por módulos reduce incidencias.
* Integrar cambios con frecuencia (no dejar ramas largas) para detectar conflictos pronto.
* Antes de empezar una gran tarea, sincronizar la rama main para partir de la versión más actual posible.
* Usar herramientas visuales de diff/merge (GitHub mismo al hacer PR muestra conflictos, o editores/IDEs tienen mergetools) que facilitan comparar y elegir cambios.
* En última instancia, si un merge se vuelve muy complejo, una estrategia es hacer un *rebase* interactivo o merge por partes, pero eso es avanzado.

En Git, **los conflictos son parte natural** del trabajo en equipo, pero el sistema provee las marcas y comandos para resolverlos de forma controlada. Lo importante es no entrar en pánico: ningún conflicto rompe el repositorio; simplemente requiere tu intervención para decidir la versión correcta del código. Una vez resueltos, Git continuará como si nada.

*(Nota: Existe el comando `git merge --abort` por si en medio de la resolución decides cancelar la fusión y dejar todo como antes, útil si prefieres resolver de otra manera o en otro momento.)*

## Claves públicas y privadas para autenticación con GitHub

Cuando usas GitHub, necesitarás **autenticarte** para operaciones que escriben en el repositorio (push, crear PRs, etc.). Una forma conveniente y segura de hacerlo es mediante un par de **claves SSH** (Secure Shell). GitHub (y otros servicios Git) soportan este método de autenticación, que evita tener que ingresar usuario y contraseña en cada interacción.

Una **clave SSH** es un par criptográfico formado por:

* una **clave privada** (que guardas únicamente tú, en tu computadora, y **no** compartes con nadie), y
* una **clave pública** (que puedes compartir, y de hecho subes a tu cuenta de GitHub).

La idea es que GitHub almacenará tu clave *pública*, y tu máquina utilizará la clave *privada*. Cuando intentas, por ejemplo, hacer `git push` vía SSH, GitHub te desafía con un mensaje cifrado con tu clave pública; tu cliente Git lo responde usando tu clave privada. Si calza, GitHub sabe que eres tú (porque solo tú tienes la privada) y permite la conexión. Todo este handshake ocurre tras bambalinas, de forma transparente, una vez configuradas las claves.

**¿Cómo se configuran?** Primero se genera el par de claves en tu equipo (si no lo tienes ya). En sistemas Linux/Mac esto se hace con el comando `ssh-keygen` (en Windows hoy día también via terminal). Por ejemplo: `ssh-keygen -t ed25519 -C "tu_email@example.com"` generará una clave usando el algoritmo ED25519 (o `-t rsa -b 4096` para RSA de 4096 bits). Al final del proceso tendrás dos archivos usualmente en `~/.ssh/`: uno llamado *id\_ed25519* (tu clave privada) y *id\_ed25519.pub* (tu clave pública). **La privada no debe salir de tu máquina ni ser compartida**, es como la llave de tu casa. La pública en cambio sí se puede distribuir.

El segundo paso es **añadir la clave pública a GitHub**. Vas a tu cuenta de GitHub (en la web), apartado "Settings" -> "SSH and GPG keys", y ahí puedes pegar el contenido de tu archivo `.pub`. Le das un nombre (por ejemplo "Laptop de Ana") para identificarla. GitHub la guardará asociada a tu usuario.

Con eso, ya puedes usar la URL *SSH* de tus repos (del tipo `git@github.com:usuario/repositorio.git`) para clonar, hacer pull/push, etc., sin introducir credenciales cada vez. De hecho, una gran ventaja es la **comodidad**: con la autenticación SSH, ya no te pide usuario/contraseña en cada `git push`, ahorrando mucho tiempo y frustración. Tu clave privada, protegida por frase de contraseña si así lo quisiste al generarla, reside en tu máquina; puedes incluso usar un agente SSH para no tener que escribir la passphrase repetidamente.

Cuando todo está configurado, es buena idea probar la conexión: GitHub sugiere ejecutar `ssh -T git@github.com`. Si todo va bien, deberías ver un mensaje de bienvenida tipo “Hi *tu\_usuario*! You've successfully authenticated...”. Eso confirma que la comunicación cifrada funciona.

**Seguridad:** Las claves SSH son muy seguras siempre que mantengas tu clave privada a salvo (por eso recalco: no la compartas, no la subas a ningún repo, protégela con passphrase). Así evitas que terceros puedan autenticarse como tú. En caso de compromiso (ej. perdiste tu laptop), puedes simplemente eliminar esa clave en la configuración de GitHub para revocarla.

**Alternativas:** Hoy GitHub ha quitado el soporte a autenticación por contraseña en Git (por seguridad). Si prefieres no usar SSH, la alternativa es usar HTTPS pero con **tokens personales** (PAT). Un token es una cadena de caracteres que generas en GitHub y usas como “password” en los comandos Git sobre HTTPS. Pero en la práctica, para desarrollo diario, las claves SSH resultan más cómodas porque una vez configuradas funcionan automáticamente. Muchos IDEs y herramientas gráficas también las usan.

En resumen, **autenticarse con clave pública/privada** es el método recomendado: ganas en seguridad (no transmites passwords en texto plano, la conexión va cifrada) y en agilidad (no tienes que tipear credenciales cada vez). Configurar una clave SSH con GitHub es un proceso de una sola vez y te beneficia en todos tus repos.

*(Nota: además de las claves de usuario, GitHub permite configurar **deploy keys** -claves por repositorio para uso de servidores- y autenticación vía **GPG** para firmar commits, pero son temas más avanzados.)*

## Integración de Git y GitHub en herramientas como *PyCharm*

Una gran ventaja de Git es que ha sido incorporado en el flujo de trabajo de la mayoría de IDEs y editores modernos. **PyCharm**, el IDE de Python de JetBrains, ofrece una integración de Git/GitHub muy completa que permite realizar prácticamente todas las acciones de control de versiones sin salir del entorno de desarrollo.

Al abrir un proyecto con PyCharm, puedes activar el **control de versiones** (si el proyecto ya es un repo Git, PyCharm lo detecta; sino, puedes hacer “Enable Version Control Integration” y elegir Git, equivalente a un `git init`). Desde ese momento, PyCharm mostrará en su interfaz los indicadores de cambios en archivos, y habilitará las opciones de Git.

**¿Qué se puede hacer desde PyCharm con Git?** Prácticamente todo:

* Registrar commits con mensajes (PyCharm tiene una ventana de *Commit* donde seleccionas qué cambios incluir –equivalente al staging–, ves el *diff* de cada archivo, escribes el mensaje y confirmas el commit).
* Ver el historial de commits gráficamente, comparar versiones de archivos (*Show History*, *Show Diff*).
* Revertir cambios o resets de commits a través de la interfaz sin tener que recordar comandos exactos.
* Gestionar **ramas**: crear, cambiar (checkout), fusionar ramas, borrar ramas, rebase, etc., mediante menús. PyCharm presenta un menú desplegable con las ramas existentes y opciones para crear nuevas o hacer checkout directo.
* Resolver conflictos de merge con herramientas gráficas de tres paneles (mostrando tu versión, la del otro branch y la resultante) haciendo muy amigable el proceso de merges complicados.

Además de Git en local, PyCharm se integra con los **servicios remotos**. En particular, con **GitHub**: en la configuración puedes **loguear tu cuenta de GitHub** en PyCharm (ya sea mediante usuario/contraseña, token personal o OAuth). Al hacer esto, el IDE puede por ejemplo:

* **Clonar repositorios de GitHub** directamente: no necesitas copiar la URL desde la web, PyCharm te lista tus repos o te permite pegar la URL *https/ssh* y él clona el repo en una carpeta local.
* **Publicar proyectos** en GitHub: si tienes un proyecto local al que quieres subir a un nuevo repo en GitHub, PyCharm tiene la opción "Share Project on GitHub" que crea el repositorio remoto en tu cuenta y hace el push inicial automáticamente.
* Facilitar la creación de **Pull Requests**: PyCharm tiene una herramienta donde puedes comparar ramas y con un click iniciar una PR en GitHub. Incluso permite ver la lista de pull requests existentes en un repo y revisar su contenido, todo desde el IDE, integrándose con la API de GitHub.
* **Forks y Gists**: Desde PyCharm es posible crear un fork de un repo en GitHub o crear *gists* (fragmentos de código compartibles) sin ir al navegador.

En esencia, PyCharm ofrece un *frontend* gráfico para Git que cubre comandos comunes y flujos de trabajo típicos (commits, push/pull, branch/merge) y también utilidades específicas de GitHub (PRs, forks). Esto mejora la productividad ya que **evita el cambio de contexto**: puedes programar, versionar y colaborar desde la misma aplicación. Por ejemplo, imagina que terminas una funcionalidad, haces commit en PyCharm, luego con un par de clics push a GitHub y abres el pull request, todo sin abrir la terminal ni el navegador. PyCharm también muestra notificaciones si hay nuevos commits en el remoto, permitiendo hacer pull fácilmente.

Otras herramientas similares: Visual Studio Code también integra Git muy bien (con su panel de Source Control), al igual que IDEs como Eclipse, IntelliJ IDEA, etc. Todas se apoyan en Git “por debajo”, pero exponen botones y atajos para quienes prefieren no escribir comandos.

En conclusión, **Git se integra profundamente en los entornos de desarrollo**. En PyCharm esto se traduce en que puedes manejar GitHub como extensión de tu IDE (clonar, autenticarte, hacer fork, revisar PRs, crear ramas remotas), lo que simplifica la colaboración. Para un estudiante o desarrollador principiante, vale la pena explorar estas integraciones porque reducen la curva de aprendizaje (te permiten usar Git con ayuda visual mientras aprendes los conceptos). No obstante, también es importante conocer la CLI de Git para cuando no tengas un IDE a mano o necesites hacer operaciones avanzadas.

*(Consejo: Prueba el flujo completo en PyCharm: haz cambios en un archivo, verás colores en la barra lateral indicando líneas modificadas; usa la ventana de Commit para ver el diff y confirmar; haz push desde PyCharm; luego haz alguna edición conflictiva en GitHub y trata de pull en PyCharm para ver cómo te asiste en la resolución. Es una buena forma de practicar Git.)*

## Buenas prácticas recomendadas (en Git y GitHub)

Finalmente, enumeramos algunas **buenas prácticas** para desarrollar software usando Git/GitHub de manera eficaz y profesional:

* **Commits pequeños, frecuentes y atómicos:** Realiza confirmaciones con alcances acotados y de forma regular, en lugar de un monolítico commit gigante. Esto facilita la revisión y el *debugging* (es más fácil encontrar en qué commit se introdujo un bug) y reduce conflictos. Un commit debe idealmente resolver una sola cosa o agregar una unidad lógica de funcionalidad.
* **Mensajes de commit descriptivos:** Escribe mensajes claros que expliquen *el qué y el porqué* del cambio. Un buen mensaje de commit en una sola línea podría ser: “Corrección de cálculo de total (evita dividir por cero)”. Si el cambio es complejo, añade un cuerpo explicativo. Evita mensajes vacíos o poco informativos como “update” o “cambios”. Piensa que tus compañeros (o tu yo futuro) leerán esos mensajes para entender la historia.
* **Uso estratégico de ramas:** Aprovecha las ramas para organizar el trabajo en paralelo. Por ejemplo, adopta la convención de ramas de feature para nuevas funcionalidades, ramas de hotfix para emergencias, etc. Trabaja en ramas aisladas en lugar de todos en main, de modo que puedas hacer PRs y pruebas sin afectar la versión estable. **Mantén las ramas de vida corta**; integra los cambios tan pronto sea razonable para evitar desviaciones largas. Borrar las ramas *feature* después de fusionarlas (si ya no se necesitan) ayuda a mantener el repositorio ordenado.
* **No trabajar con código roto en main:** Asegúrate de que la rama principal siempre compile/pase tests antes de subirla. Si aún estás desarrollando una funcionalidad incompleta, mejor mantenerla en una rama aparte hasta que esté lista (o usar feature flags si usas trunk-based). Esto mantiene la continuidad del proyecto sin interrupciones por errores evidentes en main.
* **Utiliza `.gitignore`:** Configura un archivo **.gitignore** apropiado para tu proyecto, listando los patrones de archivos que no deben incluirse en el repo (archivos temporales, binarios compilados, credenciales, dependencias externas que se reconstruyen, etc.). Esto previene que “basura” o secretos terminen bajo control de versiones por descuido.
* **Revisiones de código (Code Review):** Incorpora la práctica de que otro dev revise tu código antes de mezclarlo a ramas principales. En GitHub esto se implementa muy bien con Pull Requests, donde al menos un compañero aprueba los cambios. Las revisiones ayudan a detectar errores, propagar conocimiento del código entre el equipo y mejorar la calidad general (¡y aprendes de los comentarios!). Sé abierto a la crítica constructiva y también participa revisando el código de otros.
* **Integración continua (CI):** Si el proyecto lo permite, configura un servidor de integración continua para que ejecute automáticamente pruebas y otras verificaciones en cada push o PR. Herramientas como GitHub Actions, Jenkins, Travis CI, etc., pueden compilar el proyecto, correr los tests y alertar si algo falla. Esto sirve como red de seguridad: antes de fusionar un PR sabes si pasa todos los tests, por ejemplo. *“No rompas la build”* es una regla de oro: si CI indica fallo en main, deténte a corregirlo pronto en lugar de seguir añadiendo commits encima.
* **Mantén y extiende la cobertura de pruebas:** Relacionado con lo anterior, procura acompañar tus cambios de tests automatizados (unitarios o de integración) cuando sea posible. Un conjunto de pruebas sólido detecta problemas temprano y te da confianza al refactorizar. Si añades una funcionalidad, añade tests de esa funcionalidad. Si corriges un bug, agrega un test que falle antes y pase después, para evitar regresiones.
* **Soluciona conflictos lo antes posible:** Si ves que tu rama tiene muchos conflictos con la principal (por ejemplo, PR que se quedó abierto mucho tiempo mientras main avanzó), no esperes al último momento: haz merges o rebases intermedios para ir resolviéndolos poco a poco. Es más fácil manejar conflictos en porciones pequeñas que veinte conflictos de golpe justo antes de entregar. Y si surge un conflicto en medio del trabajo colaborativo, comunícalo y resuélvanlo conjuntamente si es complicado.
* **Comunicación y transparencia en el equipo:** Git facilita que todos vean qué cambios se han hecho. Aprovéchalo, pero también comunica contextos. Por ejemplo, comenta en el canal del equipo “acabo de fusionar la feature X, atentos por si notan algo raro en dev”. O si vas a refactorizar algo grande, avisa: “voy a refactorizar el módulo Y, puede causar conflictos si están trabajando allí”. La herramienta no reemplaza la coordinación humana. Un equipo bien sincronizado, apoyado en Git, evitará duplicar trabajo o bloquearse mutuamente.
* **Refactorización constante:** No temas refactorizar el código para mejorarlo (mantenerlo limpio, eliminar código muerto, mejorar nombres, etc.), pero hazlo en commits separados claros. Git guarda los cambios, así que confía en poder revertir si algo sale mal. La deuda técnica es más fácil de manejar con pequeños pagos frecuentes: adopta la mentalidad de dejar el código un poco mejor de como lo encontraste en cada cambio. Commits de refactor (que no cambian funcionalidad sino organización interna) con buenos mensajes son muy valiosos a largo plazo.
* **Protección de ramas críticas:** En plataformas remotas, configura protección para ramas como `main` o `develop` según tu flujo. Por ejemplo, exigir que todo merge a main pase por PR aprobado y por CI verde. Esto fuerza el cumplimiento de varias buenas prácticas (revisión, tests) de manera sistemática. También evita push accidentales a main. Es una salvaguarda útil cuando varios contribuyen.
* **No versionar secretos ni información sensible:** Ten cuidado de no incluir en commits datos privados (passwords, claves API, datos de clientes). Usa mecanismos adecuados (variables de entorno, vaults) para manejar esa información en lugar de hardcodearla. Si por error subes una credencial, **gírala** (invalidarla) de inmediato y limpia el historial (GitHub tiene herramientas para remover secretos expuestos). Un repositorio es potencialmente visible por muchos; incluso en privado, trata los commits como públicos a la hora de no poner cosas sensibles.

