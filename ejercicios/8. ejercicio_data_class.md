# Enunciado (único ejercicio): Mini-ecommerce “Cafetería”

**Objetivo:** implementar un módulo sencillo para gestionar un **catálogo**, un **carrito de compras** y el **cálculo de totales**, practicando en un mismo ejercicio:

* `dataclasses` (campos, `field(default_factory=...)`, `init=False`, `__post_init__`, `ClassVar`, `order=True`, `compare=False`)
* **pistas de tipos** (`typing`: `ClassVar`, `Optional`, `Iterable`, etc.)
* **métodos especiales** (`__repr__`, `__str__`, `__eq__`, `__len__`, `__iter__`, `__contains__`, `__getitem__`)
* **list/dict comprehensions** y buenas prácticas.

> **Módulos permitidos/sugeridos:**
> `from dataclasses import dataclass, field`
> `from typing import ClassVar, Optional, Iterable`

---

## 1) Modelo de dominio

### 1.1 `Producto` (usar **dataclass**)

Crea una dataclass `Producto` con:

* Campos:

  * `id: int`
  * `nombre: str`
  * `precio: float`  *(> 0)*
  * `categoria: Optional[str] = None`
* Constante de clase: `IVA: ClassVar[float] = 0.19`
* Orden natural: `order=True` (ordena por `precio` y, en caso de empate, por `nombre`).
* Igualdad: que **solo** compare por `id` (excluye `nombre`, `precio`, `categoria` del comparador usando `field(compare=False)` cuando corresponda).
* Validación en `__post_init__`: `precio` debe ser mayor a 0; si no, lanza `ValueError`.
* Representación:

  * `__repr__` (lo que genere dataclass es suficiente).
  * Implementa `__str__` “amigable”, por ejemplo: `"Café (10.0)"`.

### 1.2 `LineaPedido` (usar **dataclass**)

Crea una dataclass `LineaPedido` con:

* Campos:

  * `producto: Producto`
  * `cantidad: int`  *(> 0)*
  * `subtotal: float = field(init=False)`  → se calcula en `__post_init__` como `producto.precio * cantidad`.
* Métodos:

  * `total_con_iva(self) -> float` → `(producto.precio * (1 + Producto.IVA)) * cantidad`
* Validación en `__post_init__`: `cantidad` debe ser > 0; si no, `ValueError`.
* Igualdad (opcional): dos líneas son iguales si su `producto.id` coincide (ignora cantidad). *(Sugerencia: define `__eq__` custom o ajusta campos comparables.)*

### 1.3 `Carrito` (usar **clase normal**, **no** dataclass)

Crea una clase `Carrito` que mantenga internamente una colección de `LineaPedido`:

* Atributos:

  * `_lineas: list[LineaPedido]` (inicia vacío).
  * `DESCUENTO_MAX: ClassVar[float] = 0.30`  (30% máximo global)
* Métodos públicos:

  * `agregar(producto: Producto, cantidad: int) -> None`

    * Si ya existe una línea del mismo `producto.id`, **acumula** la cantidad; si no, crea una nueva `LineaPedido`.
  * `eliminar(producto_id: int) -> None`
  * `vaciar() -> None`
  * `aplicar_descuento_global(porcentaje: float) -> None`

    * Valida `0 <= porcentaje <= DESCUENTO_MAX`.
    * Aplica el descuento al **precio del producto** de cada línea *o* al total global (elige una estrategia y sé consistente).
  * `total_sin_iva(self) -> float`
  * `total_con_iva(self) -> float`

---

## 2) Utilidades y consultas

Implementa funciones **puras** auxiliares (fuera de las clases), usando **type hints** y **comprensiones**:

1. `filtrar_por_rango(precio_min: float, precio_max: float, catalogo: list[Producto]) -> list[Producto]`
   Devuelve productos cuyo `precio` esté en `[precio_min, precio_max]`, **ordenados** por el orden natural de `Producto`.

2. `resumen_carrito(carrito: Carrito) -> dict[int, float]`
   Devuelve un diccionario `{producto_id: subtotal_sin_iva}` usando **dict comprehension**.

3. `categorias_presentes(catalogo: list[Producto]) -> set[str]`
   Devuelve las categorías no nulas presentes (usa **set comprehension**). Si `categoria` es `None`, ignórala.

---

## 3) Datos de ejemplo (para tus pruebas)

Crea este catálogo mínimo (puedes ampliarlo):

```python
catalogo = [
    Producto(1, "Café", 10.0, "Bebidas"),
    Producto(2, "Té", 8.5, "Bebidas"),
    Producto(3, "Croissant", 12.0, "Panadería"),
    Producto(4, "Jugo Naranja", 9.0, "Bebidas"),
]
```

Pruebas sugeridas (no obligatorias en la entrega):

* Crear `Carrito`, agregar 2×Café, 1×Croissant, 3×Té.
* Verificar `len(carrito)`, iterar y mostrar líneas (`for lp in carrito:`).
* Comprobar `1 in carrito` (por `producto_id`).
* Aplicar `aplicar_descuento_global(0.1)` y recalcular totales.
* Usar `filtrar_por_rango(9.0, 12.0, catalogo)` y confirmar el orden.
* Obtener `resumen_carrito(carrito)` y `categorias_presentes(catalogo)`.

---

## 4) Requisitos de calidad (entregables)

* Usa **type hints** en **todas** las funciones públicas y métodos.
* Evita estados inconsistentes (p. ej., cantidades negativas).
* Representaciones (`__repr__`/`__str__`) **legibles**.



---

## 5) Criterios de aceptación mínimos

* Se puede construir un `Carrito`, agregar y eliminar productos, consultar totales con y sin IVA.
* `Producto` valida `precio > 0` y compara por `id`.
* `LineaPedido` calcula `subtotal` en `__post_init__` y valida `cantidad > 0`.
* Las tres utilidades (`filtrar_por_rango`, `resumen_carrito`, `categorias_presentes`) funcionan y usan comprensiones.

> **Consejo:** empieza por el modelo (`Producto`, `LineaPedido`), sigue con `Carrito`, y termina con las utilidades. Prueba cada parte de forma incremental en un REPL/notebook.
