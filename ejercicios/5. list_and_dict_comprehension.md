# A) List Comprehension (8 ejercicios)

```python
# A1) cuadrados_pares
# Dada una lista de enteros, devolver los cuadrados de los pares en el mismo orden.
def cuadrados_pares(nums: list[int]) -> list[int]:
    """[2,3,4] -> [4,16]"""
    ...
```

```python
# A2) longitudes_filtradas
# Dada una lista de palabras, devolver sus longitudes solo si len>=3, en minusculas.
def longitudes_filtradas(palabras: list[str]) -> list[int]:
    """["Sol","a","nube"] -> [3,4]"""
    ...
```

```python
# A3) primeras_no_vacias
# Dada una lista de strings, devolver la primera letra de cada string NO vacio.
def primeras_no_vacias(items: list[str]) -> list[str]:
    """["", "hola", "ok"] -> ["h","o"]"""
    ...
```

```python
# A4) aplanar_matriz
# Dada una matriz (lista de listas), aplanar en una sola lista (orden por filas).
def aplanar_matriz(m: list[list[int]]) -> list[int]:
    """[[1,2],[3],[4,5]] -> [1,2,3,4,5]"""
    ...
```

```python
# A5) producto_cartesiano_par
# Dados dos rangos [0..a) y [0..b), construir tuplas (i,j) con i+j par.
def producto_cartesiano_par(a: int, b: int) -> list[tuple[int, int]]:
    """a=3,b=4 -> [(0,0),(0,2),(1,1),(1,3),(2,0),(2,2)]"""
    ...
```

```python
# A6) escalar_desplazar
# Dada una lista de floats y dos parametros, retornar [x*factor + bias].
def escalar_desplazar(xs: list[float], factor: float, bias: float) -> list[float]:
    """([1.0, -2.0], 2.0, 0.5) -> [2.5, -3.5]"""
    ...
```

```python
# A7) aprobados_nombres
# Recibe lista de dicts con {"nombre": str, "notas": list[float]} y umbral.
# Devolver lista con los nombres cuya nota promedio >= umbral (orden original).
def aprobados_nombres(alumnos: list[dict[str, object]], umbral: float) -> list[str]:
    """
    [{"nombre":"Ana","notas":[4.0,3.0]},{"nombre":"Luis","notas":[2.5,3.0]}], 3.5 -> ["Ana"]
    """
    ...
```

```python
# A8) totales_con_descuento
# Recibe lista de productos como tuplas (precio: float, desc: float en [0..1]).
# Retorna lista de precios finales (precio*(1-desc)) SOLO si desc>0.
def totales_con_descuento(items: list[tuple[float, float]]) -> list[float]:
    """[(100.0,0.2),(50.0,0.0)] -> [80.0]"""
    ...
```

---

# B) Dict Comprehension (8 ejercicios)

```python
# B1) longitud_por_palabra
# Mapear palabra -> longitud para palabras con len>=3 (en minusculas).
def longitud_por_palabra(palabras: list[str]) -> dict[str, int]:
    """["Sol","a","nube"] -> {"sol":3,"nube":4}"""
    ...
```

```python
# B2) cuadrados_unicos
# Dada una lista con posibles repetidos, mapear n -> n*n pero sin repetir claves.
def cuadrados_unicos(nums: list[int]) -> dict[int, int]:
    """[2,2,3] -> {2:4, 3:9}"""
    ...
```

```python
# B3) invertir_sin_colisiones
# Invertir dict k->v solo si v es unico; si v esta repetido, excluirlo.
def invertir_sin_colisiones(d: dict[str, int]) -> dict[int, str]:
    """{"a":1,"b":2,"c":1} -> {2:"b"}"""
    ...
```

```python
# B4) frecuencia_letras
# Dado un string, contar ocurrencias de letras a-z (case-insensitive), ignorar otras.
def frecuencia_letras(texto: str) -> dict[str, int]:
    """"Hola!!!" -> {"h":1,"o":1,"l":1,"a":1}"""
    ...
```

```python
# B5) indice_por_inicial
# Dada lista de palabras, mapear inicial -> lista de palabras que comienzan con ella (ordenadas).
def indice_por_inicial(palabras: list[str]) -> dict[str, list[str]]:
    """["sol","silla","nube"] -> {"s":["silla","sol"],"n":["nube"]}"""
    ...
```

```python
# B6) promedio_por_estudiante
# Dado dict nombre -> lista de notas, devolver nombre -> promedio con 2 decimales (float).
def promedio_por_estudiante(registro: dict[str, list[float]]) -> dict[str, float]:
    """{"Ana":[4,3], "Luis":[5]} -> {"Ana":3.5,"Luis":5.0}"""
    ...
```

```python
# B7) desde_claves_valores
# Construir dict a partir de dos listas paralelas (claves y valores). Si difieren, recorta a la minima.
def desde_claves_valores(keys: list[str], vals: list[str]) -> dict[str, str]:
    """(["a","b"],[1,2,3]) -> {"a":"1","b":"2"}"""
    ...
```

```python
# B8) clasificar_caracteres
# Dado un string, mapear caracter -> categoria: "vocal", "consonante", "otro" (case-insensitive).
def clasificar_caracteres(s: str) -> dict[str, str]:
    """"aB-1" -> {"a":"vocal","b":"consonante","-":"otro","1":"otro"}"""
    ...
```

---

# C) Retos combinados (opcionales)

```python
# C1) agrupacion_por_paridad
# Dada una lista de enteros, devolver {"even":[...], "odd":[...]} con los cuadrados ordenados asc.
def agrupacion_por_paridad(nums: list[int]) -> dict[str, list[int]]:
    """[1,2,3] -> {"even":[4], "odd":[1,9]}"""
    ...
```

```python
# C2) adjacency_desde_aristas
# Dada lista de aristas no dirigidas (u,v), construir dict u->[vecinos ordenados sin repetidos] para todos los nodos.
def adjacency_desde_aristas(edges: list[tuple[int, int]]) -> dict[int, list[int]]:
    """[(1,2),(2,3),(1,3)] -> {1:[2,3],2:[1,3],3:[1,2]}"""
    ...
```

```python
# C3) resumen_palabras
# Dada lista de frases, retornar {"total_palabras": float, "unicas": float, "promedio_por_frase": float}.
def resumen_palabras(frases: list[str]) -> dict[str, float]:
    ...
```
