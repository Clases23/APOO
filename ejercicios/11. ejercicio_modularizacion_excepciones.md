# Taquilla de Cine — POO + Excepciones

## Contexto

Implementa una **taquilla de cine** que vende entradas para distintas funciones. La persona **deposita dinero**, **elige una función** y **compra** una o varias entradas. El sistema debe **validar** entradas y estados, **lanzar excepciones específicas** y **devolver el cambio** cuando aplique.

---

## Reglas generales

* **Type hints:** en **todo** (clases, funciones, atributos).
* **Colecciones:** usa `list[...]`, `dict[...,...]` 
* **Dinero:** trabaja en **pesos** (`int`).
* **Diseño:** separa **modelo** (`Showing`) de la **lógica** (`TicketOffice`).
  No mezcles I/O (no `print()`/`input()`) en la lógica de negocio.

---
```text
cinema-ticket/
├─ pyproject.toml
├─ README.md
└─ cinema/
  ├─ __init__.py          # ← vacío (marca el paquete)
  ├─ main.py              # punto de entrada: python -m cinema.main
  ├─ exceptions.py        # excepciones del dominio
  ├─ models.py            # @dataclass Showing
  └─ office.py            # TicketOffice (catálogo, cupos, balance, operaciones)

````
---

## Clases a crear

### 1) `Showing`

**Propósito:** representa una función (película en un horario) vendible.

**Atributos (con type hints):**

* `id: str` — identificador único (sin espacios).
* `title: str` — nombre de la película.
* `price: int` — precio por **entrada** en centavos (`> 0`).

**Requisitos:**

* Usa `@dataclass`
* Valida en `__post_init__`:

  * `id` no vacío → si no, lanza `InvalidShowing`.
  * `price > 0` → si no, lanza `InvalidShowing`.

---

### 2) `TicketOffice`

**Propósito:** gestiona **catálogo de funciones**, **cupos** por función, **balance** depositado y **operaciones** de compra/cancelación.

**Estado interno mínimo (elige estructuras nativas):**

* `catalog: dict[str, Showing]` — funciones por id.
* `seats: dict[str, int]` — cupos disponibles por id de función (enteros `>= 0`).
* `balance: int` — dinero depositado por la persona (centavos, `>= 0`).

**Invariantes (deben cumplirse siempre):**

* `balance >= 0`.
* Para todo `showing_id` en `seats`: `seats[showing_id] >= 0`.
* Consistencia: si existe `seats[showing_id]`, debe existir `catalog[showing_id]`.

---

## Excepciones del dominio (crear estas clases)

* `DomainError(Exception)` — base de errores del dominio.
* `InvalidAmount(DomainError)` — montos/cantidades inválidas (<= 0).
* `InvalidShowing(DomainError)` — datos inválidos de `Showing` (id vacío, precio <= 0).
* `ShowingNotFound(DomainError)` — no existe el `showing_id` solicitado.
* `SoldOut(DomainError)` — no hay cupos suficientes para la compra.
* `InsufficientFunds(DomainError)` — `balance` insuficiente para cubrir el total.
* *(Opcional)* `DuplicateShowing(DomainError)` — función repetida.

---

## Especificación **directa** de métodos

### `add_showing(showing: Showing, seats: int) -> None`

* **Qué hacer:**

  1. Valida `seats >= 0`; si no, **lanza** `InvalidAmount`.
  2. Si `showing.id` ya existe:

     * Política recomendada: **rechaza** con `DuplicateShowing`.
       (Si decides actualizar, documéntalo con claridad).
  3. Registra `showing` en `catalog` y su `seats` iniciales.
* **Postcondición:** `catalog[showing.id]` existe y `seats[showing.id] == seats`.

---

### `deposit(amount: int) -> None`

* **Qué hacer:**

  1. Valida `amount > 0`; si no, **lanza** `InvalidAmount`.
  2. Suma `amount` al `balance`.
* **Postcondición:** `balance` aumenta exactamente `amount`.

---

### `get_seats(showing_id: str) -> int`

* **Qué hacer:**

  1. Verifica existencia de `showing_id`; si no existe, **lanza** `ShowingNotFound`.
  2. Devuelve los cupos disponibles (entero `>= 0`).
* **Postcondición:** no modifica estado.

---

### `get_price(showing_id: str) -> int`

* **Qué hacer:**

  1. Verifica existencia de `showing_id`; si no existe, **lanza** `ShowingNotFound`.
  2. Devuelve el `price` por entrada de esa función (entero `> 0`).
* **Postcondición:** no modifica estado.

---

### `buy(showing_id: str, qty: int) -> int`

* **Qué hacer (en este **orden**):**

  1. Valida `qty > 0`; si no, **lanza** `InvalidAmount`.
  2. Verifica existencia de `showing_id`; si no, **lanza** `ShowingNotFound`.
  3. Verifica `seats[showing_id] >= qty`; si no, **lanza** `SoldOut`.
  4. Calcula `total = price(showing_id) * qty`.
  5. Verifica `balance >= total`; si no, **lanza** `InsufficientFunds`.
  6. Aplica efectos:

     * `seats[showing_id] -= qty`
     * `balance -= total`
     * `change = balance`
     * `balance = 0`
  7. **Devuelve** `change` (centavos; puede ser `0`).
* **Postcondiciones:**

  * Cupos disminuyen en `qty`.
  * `balance` queda en `0`.
  * Retorno = cambio.

---

### `cancel() -> int`

* **Qué hacer:**

  1. `amount = balance`
  2. `balance = 0`
  3. **Devuelve** `amount`.
* **Postcondición:** `balance` queda en `0`.

---

## Casos de aceptación (para probar manualmente)

1. **Alta y consulta**

   * `add_showing(Showing("F1", "Matrix", 1200), seats=10)`
   * `get_price("F1") == 1200`, `get_seats("F1") == 10`.
2. **Compra simple (válida)**

   * `deposit(5000)`, `buy("F1", 2)` → total `2400`, cambio `2600`, `balance == 0`, `seats("F1") == 8`.
3. **Función inexistente**

   * `get_seats("X9")` o `buy("X9", 1)` → **lanza** `ShowingNotFound`.
4. **Sin cupos suficientes**

   * `seats("F1") == 1`, `buy("F1", 2)` → **lanza** `SoldOut`.
5. **Fondos insuficientes**

   * `deposit(1000)`, `price("F1")==1200`, `buy("F1", 1)` → **lanza** `InsufficientFunds`.
6. **Cantidad inválida**

   * `buy("F1", 0)` o `buy("F1", -1)` → **lanza** `InvalidAmount`.
7. **Cancelar**

   * `deposit(2500)`, `cancel()` → retorna `2500` y `balance == 0`.

---
