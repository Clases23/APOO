# Ejercicio A (Resuelto): Sistema de Suscripciones

## Descripción

Modela un sistema para gestionar distintos tipos de **suscripciones** de una plataforma. Todas comparten atributos comunes, pero el cálculo del **precio final** varía según el tipo.

## Requisitos

### Clase base `Suscripcion`

Atributos comunes:

* `usuario: str`
* `precio_base: float`
* `plan: str` (por ejemplo: *Basic*, *Standard*, *Premium*)
* `antiguedad_meses: int`

Métodos:

* `calcular_precio() -> float`
* `info() -> str` (devuelve datos básicos del usuario/suscripción)

### Tipos de suscripción (subclases)

* **Premium**: además del precio base, tiene un **cargo adicional**.
* **Educativa**: aplica un **descuento** al precio base.
* **Prepago**: **no** tiene precio base; el precio se calcula como `paquetes * tarifa_por_paquete`.

## Tareas

1. Diseñar la jerarquía usando **herencia** para evitar duplicación.
2. **Sobrescribir** `calcular_precio()` en las subclases que cambien el cálculo.
3. **Polimorfismo**: función que reciba una `Suscripcion` y muestre su info + precio final.

## Ejemplo de salida esperada

```
Usuario: Ana, Plan: Premium, Antigüedad: 24 meses
Precio final: 140.0

Usuario: Luis, Plan: Educativa, Antigüedad: 6 meses
Precio final: 55.0

Usuario: Jorge, Plan: Prepago, Antigüedad: 1 meses
Precio final: 90.0
```

## Solución (`@override`, type hints)

```python
from typing import override, List

class Suscripcion:

    def __init__(self, usuario: str, precio_base: float, plan: str, antiguedad_meses: int) -> None:
        self.usuario: str = usuario
        self.precio_base: float = precio_base
        self.plan: str = plan
        self.antiguedad_meses: int = antiguedad_meses

    def calcular_precio(self) -> float:
        # Implementación por defecto: retorna el precio base
        return self.precio_base

    def info(self) -> str:
        return f"Usuario: {self.usuario}, Plan: {self.plan}, Antigüedad: {self.antiguedad_meses} meses"


class Premium(Suscripcion):
    cargo_adicional: float

    def __init__(self, usuario: str, precio_base: float, plan: str, antiguedad_meses: int, cargo_adicional: float) -> None:
        super().__init__(usuario, precio_base, plan, antiguedad_meses)
        self.cargo_adicional = cargo_adicional

    @override
    def calcular_precio(self) -> float:
        # base + cargo
        return self.precio_base + self.cargo_adicional


class Educativa(Suscripcion):

    def __init__(self, usuario: str, precio_base: float, plan: str, antiguedad_meses: int, descuento: float) -> None:
        super().__init__(usuario, precio_base, plan, antiguedad_meses)
        self.descuento: float = descuento

    @override
    def calcular_precio(self) -> float:
        # base - descuento (no negativo)
        return max(0.0, self.precio_base - self.descuento)


class Prepago(Suscripcion):

    def __init__(self, usuario: str, plan: str, antiguedad_meses: int, paquetes: int, tarifa_por_paquete: float) -> None:
        # En prepago no se usa precio_base → lo fijamos a 0.0
        super().__init__(usuario, precio_base=0.0, plan=plan, antiguedad_meses=antiguedad_meses)
        self.paquetes: int = paquetes
        self.tarifa_por_paquete: float = tarifa_por_paquete

    @override
    def calcular_precio(self) -> float:
        # sin base: paquetes * tarifa
        return self.paquetes * self.tarifa_por_paquete


# (Opcional) Polimorfismo: misma interfaz para todas las suscripciones
def mostrar_resumen(s: Suscripcion) -> None:
    print(s.info())
    print("Precio final:", s.calcular_precio())
    print()


s1 = Premium(usuario="Ana", precio_base=120.0, plan="Premium", antiguedad_meses=24, cargo_adicional=20.0)   # 140.0
s2 = Educativa(usuario="Luis", precio_base=70.0, plan="Educativa", antiguedad_meses=6, descuento=15.0)      # 55.0
s3 = Prepago(usuario="Jorge", plan="Prepago", antiguedad_meses=1, paquetes=9, tarifa_por_paquete=10.0)      # 90.0

# Puedes llamar individualmente:
# print(s1.info()); print(s1.calcular_precio())

# O usar la función polimórfica:
suscripciones: List[Suscripcion] = [s1, s2, s3]
for s in suscripciones:
    mostrar_resumen(s)
```

---

# Ejercicio B (Para estudiantes): Sistema de Pedidos

## Descripción

Diseña un sistema para gestionar diferentes **pedidos**. Todos comparten atributos comunes, pero el **precio final** puede variar según el tipo de pedido.

## Requisitos

### Clase base `Pedido`

Atributos comunes:

* `cliente: str`
* `precio_base: float`
* `categoria: str` (por ejemplo: *Nacional*, *Internacional*, *Express*)
* `dias_entrega: int`

Métodos:

* `calcular_total() -> float`
* `info() -> str`

### Tipos de pedido (subclases)

* **Express**: al precio base se suma un **recargo de urgencia**.
* **ConCupon**: al precio base se le aplica un **descuento** (resta).
* **PorPeso**: **no** usa `precio_base`; el total se calcula como `peso_kg * tarifa_kg`.

## Tareas

1. Crea la jerarquía de clases (`Pedido` base + subclases) usando **herencia**.
2. **Sobrescribe** `calcular_total()` en cada subclase que cambie el cálculo.
3. (Opcional) Implementa una función **polimórfica** que reciba un `Pedido` y muestre su info y total.

## Ejemplo de salida esperada

```
Cliente: Carla, Categoría: Express, Días: 2
Total: 125.0

Cliente: Diego, Categoría: ConCupon, Días: 5
Total: 80.0

Cliente: Rosa, Categoría: PorPeso, Días: 7
Total: 96.0
```

*(Ejemplo si: base=100, recargo=25; base=90, descuento=10; peso=12 kg, tarifa=8.0)*

## Starter code (skeleton con TODOs) — `@override`, type hints

```python
from typing import override

class Pedido:

    def __init__(self, cliente: str, precio_base: float, categoria: str, dias_entrega: int) -> None:
        # TODO: asignar atributos
        ...

    def calcular_total(self) -> float:
        # Implementación por defecto (puedes dejarla como base o levantar NotImplementedError)
        # return self.precio_base
        ...
    
    def info(self) -> str:
        # TODO: retornar "Cliente: {self.cliente}, Categoría: {self.categoria}, Días: {self.dias_entrega}"
        ...


class Express(Pedido):

    def __init__(self, cliente: str, precio_base: float, categoria: str, dias_entrega: int, recargo_urgencia: float) -> None:
        # TODO: llamar a super().__init__ y asignar recargo_urgencia
        ...

    @override
    def calcular_total(self) -> float:
        # TODO: total = precio_base + recargo_urgencia
        ...


class ConCupon(Pedido):

    def __init__(self, cliente: str, precio_base: float, categoria: str, dias_entrega: int, descuento: float) -> None:
        # TODO: llamar a super().__init__ y asignar descuento
        ...

    @override
    def calcular_total(self) -> float:
        # TODO: total = max(0.0, precio_base - descuento)
        ...


class PorPeso(Pedido):

    def __init__(self, cliente: str, categoria: str, dias_entrega: int, peso_kg: float, tarifa_kg: float) -> None:
        # En PorPeso no usamos precio_base → pásalo como 0.0 a la base
        # TODO: super().__init__(cliente, 0.0, categoria, dias_entrega)
        # TODO: asignar peso_kg y tarifa_kg
        ...

    @override
    def calcular_total(self) -> float:
        # TODO: total = peso_kg * tarifa_kg
        ...

# Reemplaza estos ejemplos con tus propios datos de prueba
# Ejemplo 1 (Express): base=100, recargo=25  → total=125
p1 = Express(cliente="Carla", precio_base=100.0, categoria="Express", dias_entrega=2, recargo_urgencia=25.0)

# Ejemplo 2 (ConCupon): base=90, descuento=10 → total=80
p2 = ConCupon(cliente="Diego", precio_base=90.0, categoria="ConCupon", dias_entrega=5, descuento=10.0)

# Ejemplo 3 (PorPeso): peso=12kg, tarifa=8 → total=96
p3 = PorPeso(cliente="Rosa", categoria="PorPeso", dias_entrega=7, peso_kg=12.0, tarifa_kg=8.0)

# TODO: imprime info() y calcular_total() de cada uno, con saltos de línea entre ellos
# print(p1.info()); print("Total:", p1.calcular_total()); print()
# print(p2.info()); print("Total:", p2.calcular_total()); print()
# print(p3.info()); print("Total:", p3.calcular_total()); print()

# (Opcional) Implementa una función mostrar_resumen(pedido: Pedido) y úsala aquí.
```