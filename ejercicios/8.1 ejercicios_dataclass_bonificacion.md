# Ejercicio: RecipeBox — Organizador simple de recetas

## Enunciado

Crea un organizador sencillo de recetas, sus categorías e ingredientes.

### Requisitos

* `Receta` (**dataclass**):

  * Campos: `id: int`, `nombre: str`, `categoria: str`, `ingredientes: list[str]` (lista propia por instancia).
  * Validar en `__post_init__`: `nombre` y `categoria` no vacíos; `ingredientes` sin cadenas vacías (ignora espacios).
* `GestorRecetas` (**clase normal**, sin herencia):

  * Atributo público: `recetas: list[Receta] = []`.
  * Métodos:

    * `agregar(r: Receta) -> None` (rechaza `id` duplicado, sin `any`).
    * `eliminar(id_receta: int) -> None` (sin `enumerate`).
    * `listar() -> list[Receta]`.
    * `filtrar_por_categoria(cat: str) -> list[Receta]` (case-insensitive).
    * `recetas_por_ingrediente(ing: str) -> list[Receta]` (case-insensitive, pertenencia en la lista).
    * `ingredientes_mas_usados() -> dict[str, int]` (conteo global; **dict comprehension**).
    * `top_n_por_ingredientes(n: int) -> list[Receta]` (más ingredientes primero).
  * Único dunder: `__repr__(self) -> str`.

---
```python
# starter_recipebox.py
# ============================================================
# Ejercicio: RecipeBox — Organizador simple de recetas
# Objetivo:
#   - Practicar dataclasses, type hints, list/dict comprehensions
#   - Sin herencia, atributos públicos
#   - Único dunder permitido: __repr__ en el contenedor
#   - No usar any() ni enumerate()
# Python 3.9+ (usa list[str], dict[str, int])
# ============================================================

from dataclasses import dataclass, field

# ------------------------------------------------------------
# TODO 1: Implementar la dataclass Receta
# Requisitos:
#   - Clase pública sin herencia
#   - Campos:
#       id: int
#       nombre: str
#       categoria: str
#       ingredientes: list[str]  (cada instancia debe tener su propia lista)
#         -> usa field(default_factory=list)
#   - __post_init__:
#       * validar que nombre y categoria no estén vacíos (usar .strip())
#       * normalizar ingredientes: hacer .strip() a cada uno y descartar vacíos
#       * dejar la lista final en self.ingredientes 
# ------------------------------------------------------------

# Pega tu implementación de 'Receta' aquí ↓
# (no elimines esta línea)
# ============================================================







# ============================================================


# ------------------------------------------------------------
# Contenedor (clase normal, sin herencia)
#   - Atributo público: recetas: list[Receta]
#   - Implementar TODOS los métodos marcados con TODO
#   - No usar any() ni enumerate()
#   - Único dunder permitido: __repr__
# ------------------------------------------------------------
class GestorRecetas:
    def __init__(self) -> None:
        # TODO 2.0: inicializar lista pública de recetas
        # Requisito: atributo público 'recetas' con type hint list[Receta]
        # Ejemplo de intención: self.recetas: list[Receta] = []
        # Implementa aquí:
        pass

    def agregar(self, r: 'Receta') -> None:
        """
        TODO 2.1: Agregar una receta
        - Rechazar ID duplicado (comparar r.id con los ids existentes en self.recetas)
        - No usar any(); recorre con un for clásico
        - Si hay duplicado, lanzar ValueError(f"ID duplicado: {r.id}")
        """
        pass

    def eliminar(self, id_receta: int) -> None:
        """
        TODO 2.2: Eliminar receta por id
        - No usar enumerate()
        - Recorre por índice: for i in range(len(self.recetas)):
            si self.recetas[i].id == id_receta -> pop(i) y return
        - Si no se encuentra, lanzar ValueError(f"No existe receta con id={id_receta}")
        """
        pass

    def listar(self) -> list['Receta']:
        """
        TODO 2.3: Devolver una copia superficial de la lista de recetas
        - Sugerencia: list(self.recetas)
        """
        pass

    def filtrar_por_categoria(self, cat: str) -> list['Receta']:
        """
        TODO 2.4: Filtrar por categoría (case-insensitive)
        - Normaliza cat con .lower().strip()
        - Usa list comprehension para devolver recetas cuya categoría coincida
        """
        pass

    def recetas_por_ingrediente(self, ing: str) -> list['Receta']:
        """
        TODO 2.5: Recetas que contienen un ingrediente (case-insensitive)
        - Normaliza ing con .lower().strip()
        - SIN any(): usa bucles anidados para verificar si el ingrediente está en r.ingredientes
          (comparando en minúsculas)
        - Retorna una lista con las recetas que lo contengan
        """
        pass

    def ingredientes_mas_usados(self) -> dict[str, int]:
        """
        TODO 2.6: Conteo global de ingredientes
        - Construir un diccionario {ingrediente_en_minusculas: conteo}
        - Recorre todas las recetas y sus ingredientes
        - Puedes devolver el dict directamente o, opcionalmente,
          construir un dict comprehension final desde un dict acumulado
        """
        pass

    def top_n_por_ingredientes(self, n: int) -> list['Receta']:
        """
        TODO 2.7: Top-N por número de ingredientes
        - Ordenar self.recetas por len(r.ingredientes) en orden descendente
          (usa sorted(..., key=..., reverse=True))
        - Retornar el slice [:max(0, n)]
        """
        pass

    def __repr__(self) -> str:
        return f"GestorRecetas({len(getattr(self, 'recetas', []))} recetas)"


# ------------------------------------------------------------
#                  DEMO RÁPIDA 
#    * Descomenta cuando termines tus TODOs *
# ------------------------------------------------------------
#     gr = GestorRecetas()
#     # Crea algunas recetas y agrégalas
#     gr.agregar(Receta(1, "Pasta Alfredo", "Italiana", ["pasta", " crema ", "queso"]))
#     gr.agregar(Receta(2, "Ensalada César", "Ensaladas", ["lechuga", "pollo", "queso"]))
#     gr.agregar(Receta(3, "Sándwich", "Rápida", ["pan", "queso", "jamón", "tomate"]))
#     gr.agregar(Receta(4, "Jugo de Naranja", "Bebidas", ["naranja", "agua"]))
#     gr.agregar(Receta(5, "Tostadas", "Rápida", ["pan", "mantequilla"]))
#
#     print(gr)  # -> GestorRecetas(X recetas)
#     print("Listado:")
#     for r in gr.listar():
#         print(" -", r)
#
#     print("\nPor categoría 'rápida':")
#     for r in gr.filtrar_por_categoria("rápida"):
#         print(" -", r)
#
#     print("\nCon ingrediente 'queso':")
#     for r in gr.recetas_por_ingrediente("Queso"):
#         print(" -", r)
#
#     print("\nIngredientes más usados:")
#     print(gr.ingredientes_mas_usados())
#
#     print("\nTop 3 por #ingredientes:")
#     for r in gr.top_n_por_ingredientes(3):
#         print(f" - {r.nombre} ({len(r.ingredientes)} ingredientes)")
#
#     gr.eliminar(5)
#     print("\nTras eliminar id=5:", gr)
```
